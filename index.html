<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>RACCOON'S QUEST</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;background:#000;font-family:'Press Start 2P',monospace;touch-action:manipulation;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;}
#c{display:block;position:absolute;top:0;left:0;touch-action:none;}
#hud{position:absolute;top:0;left:0;right:0;height:56px;background:linear-gradient(180deg,rgba(4,1,18,.96)0%,rgba(4,1,18,.5)80%,transparent);display:flex;align-items:center;justify-content:space-between;padding:0 24px;z-index:10;pointer-events:none;}
.hb{display:flex;flex-direction:column;gap:2px;}
.hl{font-size:9px;color:#8866aa;letter-spacing:1px;text-transform:uppercase;}
.hv{font-size:20px;letter-spacing:1px;}
.hv.gold{color:#FFD700;text-shadow:0 0 10px rgba(255,215,0,.7);}
.hv.grn{color:#44ff88;text-shadow:0 0 8px rgba(68,255,136,.6);}
.hv.red{color:#ff4444;animation:blink .3s infinite alternate;}
.hv.inv{color:#FFD700;animation:invpulse .2s infinite alternate;}
@keyframes blink{to{opacity:.2}}
@keyframes invpulse{from{color:#FFD700;text-shadow:0 0 8px #FFD700;}to{color:#ff8800;text-shadow:0 0 20px #ff8800;}}
#palert{position:absolute;top:60px;left:50%;transform:translateX(-50%);background:rgba(6,1,22,.97);border:2px solid #9945FF;padding:9px 22px;text-align:center;font-size:11px;color:#ccc;display:none;z-index:11;pointer-events:none;white-space:nowrap;box-shadow:0 0 24px rgba(153,69,255,.8);}
#palert.on{display:block;}
#palert .pw{color:#14F195;font-size:18px;margin:4px 0;text-shadow:0 0 8px rgba(20,241,149,.6);}
#invbanner{position:absolute;top:25%;left:50%;transform:translate(-50%,-50%);background:rgba(60,30,0,.97);border:2px solid #FFD700;padding:12px 30px;text-align:center;font-size:16px;color:#FFD700;display:none;z-index:12;pointer-events:none;white-space:nowrap;box-shadow:0 0 20px rgba(255,180,0,.6);}
#invbanner.on{display:block;animation:invpulse .3s infinite alternate;}
.gambleResult{position:absolute;top:25%;left:50%;transform:translate(-50%,-50%);padding:20px 40px;text-align:center;font-size:24px;display:none;z-index:15;pointer-events:none;white-space:nowrap;border-radius:8px;}
.gambleResult.win{background:rgba(20,100,40,.95);border:3px solid #44ff88;color:#44ff88;box-shadow:0 0 30px rgba(68,255,136,.8);animation:resultPulse .4s ease-out;}
.gambleResult.lose{background:rgba(100,20,20,.95);border:3px solid #ff4444;color:#ff4444;box-shadow:0 0 30px rgba(255,68,68,.8);animation:resultPulse .4s ease-out;}
.gambleResult.show{display:block;}
@keyframes resultPulse{0%{transform:translate(-50%,-50%) scale(0.8);opacity:0;}50%{transform:translate(-50%,-50%) scale(1.1);}100%{transform:translate(-50%,-50%) scale(1);opacity:1;}}
#livdiv{position:absolute;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:6px;z-index:10;pointer-events:none;}
#hint{position:absolute;bottom:60px;left:50%;transform:translateX(-50%);font-size:13px;color:rgba(255,255,255,.24);z-index:10;pointer-events:none;text-align:center;}
#ov{position:absolute;inset:0;background:radial-gradient(ellipse at 50% 45%,rgba(10,3,28,.97),rgba(1,0,6,.99));display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;z-index:30;}
#ov.hide{display:none;}
#victoryScreen{position:absolute;inset:0;background:radial-gradient(ellipse at 50% 45%,rgba(10,3,28,.98),rgba(1,0,6,.99));display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:40;opacity:0;}
.otit{text-align:center;line-height:1;}
.otit img{max-width:min(80vw,500px);height:auto;display:block;margin:0 auto;image-rendering:crisp-edges;filter:drop-shadow(0 0 12px rgba(255,215,0,.4));}
.osub{font-size:10px;color:#9977cc;text-align:center;line-height:2.8;max-width:500px;}
.ores{font-size:14px;text-align:center;line-height:2.4;}
.ores.win{color:#44ff88;text-shadow:0 0 10px rgba(68,255,136,.5);}
.ores.lose{color:#ff4444;}
.brow{display:flex;align-items:center;gap:9px;}
.bbtn{font-family:'Press Start 2P',monospace;font-size:11px;padding:10px 16px;background:#0a0220;border:1px solid #331670;color:#999;cursor:pointer;transition:.1s;min-width:44px;min-height:44px;}
.bbtn:hover{border-color:#9945FF;color:#9945FF;}
#bip{font-family:'Press Start 2P',monospace;font-size:14px;width:110px;background:#050210;border:2px solid #331670;color:#9945FF;text-align:center;padding:8px;min-height:44px;}
.pbtn{font-family:'Press Start 2P',monospace;font-size:12px;padding:16px 32px;background:linear-gradient(135deg,#350878,#130228);border:2px solid #9945FF;color:#fff;cursor:pointer;box-shadow:0 0 20px rgba(153,69,255,.5);transition:.15s;min-height:48px;}
.pbtn:hover{background:linear-gradient(135deg,#501898,#200448);transform:scale(1.04);box-shadow:0 0 36px rgba(153,69,255,.8);}
.pbtn:active{transform:scale(0.98);}
#bline{font-size:9px;color:#444;}
#bline span{color:#FFD700;}
#crashbig{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);display:none;z-index:40;pointer-events:none;text-align:center;}
#crashtext{font-size:clamp(28px,6vw,72px);color:#ff1100;text-shadow:0 0 30px #ff4400,0 0 60px #ff0000;animation:crashani .15s infinite alternate;}
#crashsub{font-size:clamp(12px,3vw,24px);color:#ff6644;text-shadow:0 0 10px #ff4400;margin-top:12px;}
@keyframes crashani{to{transform:scale(1.08);}}

/* Tutorial message for first portal */
#tutorialMsg{position:absolute;font-size:13px;color:#14F195;text-shadow:0 0 12px rgba(20,241,149,.9);z-index:20;pointer-events:none;text-align:center;font-family:'Press Start 2P';line-height:1.6;opacity:0;transition:opacity .3s;}
#tutorialMsg.show{opacity:1;animation:tutorialPulse .8s ease-in-out infinite alternate;}
#tutorialArrow{position:absolute;font-size:32px;z-index:20;pointer-events:none;opacity:0;transition:opacity .3s;}
#tutorialArrow.show{opacity:1;animation:arrowBounce 1s ease-in-out infinite;}
@keyframes tutorialPulse{from{text-shadow:0 0 12px rgba(20,241,149,.9);transform:scale(1);}to{text-shadow:0 0 24px rgba(20,241,149,1),0 0 36px rgba(20,241,149,.6);transform:scale(1.05);}}
@keyframes arrowBounce{0%,100%{transform:translateY(0);}50%{transform:translateY(-12px);}}

/* Mobile responsive styles */
@media screen and (max-width: 768px) {
  #hud{padding:0 12px;height:48px;}
  .hb{gap:1px;}
  .hl{font-size:7px;}
  .hv{font-size:16px;}
  #scoreDisplay{top:15px;font-size:11px;}
  #palert{top:50px;font-size:9px;padding:7px 16px;}
  .pw{font-size:14px!important;}
  #invbanner{font-size:13px;padding:10px 24px;top:20%;}
  .gambleResult{font-size:18px;padding:16px 28px;}
  .otit img{max-width:80vw!important;}
  .osub{font-size:9px;padding:0 20px;}
  .ores{font-size:12px;}
  .bbtn{font-size:9px;padding:8px 12px;}
  #bip,#bipVictory{font-size:12px;width:90px;padding:6px;}
  .pbtn{font-size:10px;padding:12px 24px;}
  #bline,#blineVictory{font-size:8px;}
  #victoryMessage{font-size:clamp(28px,8vw,48px)!important;}
  #victoryAmount{font-size:clamp(18px,5vw,28px)!important;}
  #victoryDance{width:200px!important;height:200px!important;}
  #hint{font-size:11px;bottom:50px;}
  .brow{gap:6px;}
  #tutorialMsg{font-size:11px;}
  #tutorialArrow{font-size:28px;}
}

@media screen and (max-width: 480px) {
  #hud{padding:0 8px;height:44px;}
  .hl{font-size:6px;}
  .hv{font-size:14px;}
  #scoreDisplay{font-size:10px;}
  #palert{font-size:8px;padding:6px 12px;}
  #invbanner{font-size:11px;padding:8px 20px;}
  .otit img{max-width:70vw!important;}
  .osub{font-size:8px;line-height:2.2;}
  .bbtn{font-size:8px;padding:6px 10px;}
  #bip,#bipVictory{font-size:11px;width:80px;}
  .pbtn{font-size:9px;padding:10px 20px;}
  #victoryDance{width:160px!important;height:160px!important;}
  #hint{font-size:10px;bottom:40px;}
  #tutorialMsg{font-size:9px;line-height:1.5;}
  #tutorialArrow{font-size:24px;}
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<audio id="bgmusic" loop>
  <source src="bgmusic.mp3" type="audio/mpeg">
</audio>
<audio id="invmusic" loop>
  <source src="invincible.mp3" type="audio/mpeg">
</audio>
<audio id="firemusic" loop>
  <source src="fire.mp3" type="audio/mpeg">
</audio>
<audio id="cashoutmusic">
  <source src="cashout.mp3" type="audio/mpeg">
</audio>
<div id="hud">
  <div class="hb"><div class="hl">MULTIPLIER</div><div class="hv gold" id="hm">√ó1.00</div></div>
  <div class="hb" style="align-items:flex-end">
    <div class="hl" style="color:#ff6600">MONEY IS POWER</div>
    <div class="hv gold" id="goldcount">üü° 0</div>
    <div style="width:120px;height:8px;background:rgba(255,215,0,.2);border:1px solid #FFD700;margin-top:4px;position:relative">
      <div id="goldgauge" style="width:0%;height:100%;background:linear-gradient(90deg,#FFD700,#ff8800);box-shadow:0 0 8px rgba(255,215,0,.8);transition:width .3s"></div>
    </div>
  </div>
</div>
<div id="scoreDisplay" style="position:absolute;top:20px;left:50%;transform:translateX(-50%);font-size:14px;color:#9945FF;text-shadow:0 0 8px rgba(153,69,255,.6);z-index:11;pointer-events:none;font-family:'Press Start 2P';">SCORE: <span id="scoreValue" style="color:#14F195;">0</span></div>
<div id="palert" class="on"><div id="palertmsg">wait for next portal to cash out</div><div class="pw" id="pwtxt" style="display:none">+0.00 SOL</div><div id="palertsub" style="font-size:9px;color:#8855bb;margin-top:2px;display:none">keep running for more‚Ä¶or less</div></div>
<div id="invbanner">‚ö° INVINCIBLE! √ó1.5 SPEED!</div>
<div id="gambleResult" class="gambleResult"></div>
<div id="livdiv"></div>
<div id="hint">SPACE / TAP TO JUMP<br>(2 times to double jump)</div>
<div id="tutorialMsg">DOUBLE JUMP INTO PORTAL<br>TO CASH OUT<br><span style="font-size:10px;color:#9977cc">(or keep going)</span></div>
<div id="tutorialArrow">‚Üì</div>
<div id="crashbig">
  <div id="crashtext">GAME OVER</div>
  <div id="crashsub"></div>
</div>
<div id="ov">
  <img src="assets/images/image_001.png" style="width:200px;height:200px;image-rendering:crisp-edges;margin-bottom:-30px;">
  <div class="otit" id="otit"><img src="assets/images/image_002.png" alt="RACCOON'S QUEST"></div>
  <div class="osub" id="osub">Survive waves of enemies<br>Catch coins, golden bulls and unicorns<br>Jump into <span style="color:#9945FF">portals</span> to cash out (double jump)<br><span style="color:#ff6600">Miss the portal = keep going ¬∑ Die = lose bet</span><br><span style="color:#ff4444">Cash out before the wall of death!</span></div>
  <div class="brow">
    <button class="bbtn" onclick="adjBet(-.05)">‚àí</button>
    <input id="bip" type="number" value="0.10" min="0.01" max="0.5" step="0.01">
    <button class="bbtn" onclick="adjBet(.05)">+</button>
  </div>
  <div id="betusd" style="font-size:10px;color:#888;margin-top:4px;text-align:center;">($20.00)</div>
  <div id="bline">Balance: <span id="bsp">10.00</span> SOL (demo) <button onclick="resetBalance()" style="font-size:8px;padding:2px 6px;background:#331670;border:1px solid #6633bb;color:#9945FF;cursor:pointer;margin-left:8px;">Reset</button></div>
  <div id="ores" class="ores"></div>
  <button class="pbtn" id="pbtn" onclick="startGame()">‚ñ∂ START THE QUEST</button>
  <button class="pbtn" id="homebtn" onclick="location.reload()" style="display:none;margin-top:12px;font-size:10px;padding:10px 20px;background:#1a0a2e;border-color:#6633bb;">üè† HOME</button>
</div>
<div id="victoryScreen" style="display:none;">
  <div style="text-align:center;">
    <img id="victoryDance" style="width:300px;height:300px;image-rendering:crisp-edges;display:block;margin:0 auto;" alt="Victory Dance">
    <div id="victoryMessage" style="font-size:48px;color:#FFD700;text-shadow:0 0 20px rgba(255,215,0,.8);margin-top:20px;font-family:'Press Start 2P';">CONGRATS BRO!</div>
    <div id="victoryAmount" style="font-size:28px;color:#14F195;margin-top:15px;font-family:'Press Start 2P';"></div>
    
    <!-- Bet input section -->
    <div style="margin-top:30px;display:flex;flex-direction:column;align-items:center;gap:12px;">
      <div class="brow">
        <button class="bbtn" onclick="adjustBetVictory(-.01)">‚àí</button>
        <input type="number" id="bipVictory" step="0.01" min="0.01" max="0.50" value="0.10" style="font-family:'Press Start 2P',monospace;font-size:14px;width:110px;background:#050210;border:2px solid #331670;color:#9945FF;text-align:center;padding:8px;">
        <button class="bbtn" onclick="adjustBetVictory(.01)">+</button>
      </div>
      <div id="betVictoryUsd" style="font-size:9px;color:#888;">($20.00)</div>
      <div id="blineVictory" style="font-size:9px;color:#444;margin-top:4px;">Balance: <span id="bspVictory">10.00</span> SOL (demo)</div>
    </div>
    
    <button class="pbtn" id="victoryPlayBtn" onclick="startGameFromVictory()" style="margin-top:24px;">‚Ü∫ TRY AGAIN</button>
    <button class="pbtn" onclick="location.reload()" style="margin-top:12px;font-size:10px;padding:10px 20px;background:#1a0a2e;border-color:#6633bb;">üè† HOME</button>
  </div>
</div>
<div id="gambleScreen" style="display:none;position:absolute;inset:0;background:radial-gradient(ellipse at 50% 45%,rgba(60,10,80,.98),rgba(10,1,20,.99));flex-direction:column;align-items:center;justify-content:center;z-index:50;">
  <div style="text-align:center;">
    <div style="font-size:36px;color:#ff88ff;text-shadow:0 0 20px rgba(255,136,255,.8);margin-bottom:30px;font-family:'Press Start 2P';">ü¶Ñ UNICORN GAMBLE!</div>
    <div id="gambleText" style="font-size:18px;color:#fff;margin-bottom:30px;font-family:'Press Start 2P';line-height:1.8;"></div>
    <div style="display:flex;gap:30px;justify-content:center;">
      <button class="pbtn" onclick="resolveGamble(true)" style="background:#44ff88;border-color:#44ff88;color:#000;">RISK IT! üé≤</button>
      <button class="pbtn" onclick="resolveGamble(false)" style="background:#ff4444;border-color:#ff4444;">KEEP IT SAFE</button>
    </div>
  </div>
</div>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ASSETS ‚Äî preload raccoon frames (black bg removed)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const FRAMES_B64 = [
  "assets/images/image_003.png",
  "assets/images/image_004.png"
];
const BULL_RIDE_FRAMES = [
  "assets/images/image_005.png",
  "assets/images/image_006.png",
  "assets/images/image_007.png",
  "assets/images/image_008.png",
  "assets/images/image_009.png",
  "assets/images/image_010.png",
  "assets/images/image_011.png",
  "assets/images/image_012.png",
  "assets/images/image_013.png",
  "assets/images/image_014.png",
  "assets/images/image_015.png",
  "assets/images/image_016.png",
  "assets/images/image_017.png",
  "assets/images/image_018.png",
  "assets/images/image_019.png",
  "assets/images/image_020.png"
];

const bullRideFrames = [];
let bullRideLoaded = 0;
BULL_RIDE_FRAMES.forEach((src, i) => {
  const img = new Image();
  img.onload = () => { bullRideLoaded++; };
  img.src = src;
  bullRideFrames.push(img);
});

const raccoonFrames = [];
let assetsLoaded = 0;
FRAMES_B64.forEach((src,i)=>{
  const img = new Image();
  img.onload = ()=>{ assetsLoaded++; };
  img.src = src;
  raccoonFrames.push(img);
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VICTORY ANIMATION FRAMES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const VICTORY_FRAMES_B64 = [
  'assets/images/image_021.png',
  'assets/images/image_022.png'
];
const victoryFrames = [];
VICTORY_FRAMES_B64.forEach(src => {
  const img = new Image();
  img.src = src;
  victoryFrames.push(img);
});
let victoryAnimFrame = 0;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// KO ANIMATION FRAMES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const KO_FRAMES_B64 = [
  'assets/images/image_023.png',
  'assets/images/image_024.png',
  'assets/images/image_025.png',
  'assets/images/image_026.png'
];
const koFrames = [];
KO_FRAMES_B64.forEach(src => {
  const img = new Image();
  img.src = src;
  koFrames.push(img);
});



// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CANVAS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const cv=document.getElementById('c'), ctx=cv.getContext('2d');
let W,H,GY;
function resize(){
  W=cv.width=window.innerWidth;
  H=cv.height=window.innerHeight;
  // Sur mobile, mettre le sol tr√®s bas pour avoir √©norm√©ment de vue au-dessus
  const groundRatio = W <= 768 ? 0.88 : 0.74;
  GY=Math.floor(H*groundRatio);
}
window.addEventListener('resize',resize);resize();

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// AUDIO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let AC=null;
function ia(){if(!AC)AC=new(window.AudioContext||window.webkitAudioContext)();}
function beep(f,t,d,v=.2,sw=null){if(!AC)return;const o=AC.createOscillator(),g=AC.createGain();o.connect(g);g.connect(AC.destination);o.type=t;if(sw)o.frequency.setValueAtTime(sw,AC.currentTime),o.frequency.exponentialRampToValueAtTime(f,AC.currentTime+d);else o.frequency.setValueAtTime(f,AC.currentTime);g.gain.setValueAtTime(v,AC.currentTime);g.gain.exponentialRampToValueAtTime(.001,AC.currentTime+d);o.start();o.stop(AC.currentTime+d);}
const sJump=()=>beep(340,'square',.11,.16,170);
const sHit=()=>{beep(80,'sawtooth',.2,.4);beep(55,'square',.25,.3);};
const sCoin=()=>{beep(880,'square',.055,.18);setTimeout(()=>beep(1100,'square',.055,.16),55);setTimeout(()=>beep(1320,'square',.065,.13),110);};
const sPortal=()=>[440,554,659,784,1047].forEach((f,i)=>setTimeout(()=>beep(f,'sine',.16,.22),i*50));
const sCash=()=>{
  // Jouer le fichier audio cashout.mp3
  const cashoutAudio = document.getElementById('cashoutmusic');
  cashoutAudio.currentTime = 0;
  cashoutAudio.play().catch(e => console.log('Cashout sound play prevented:', e));
};
const sDeath=()=>[440,330,220,165,110].forEach((f,i)=>setTimeout(()=>beep(f,'sawtooth',.2,.32),i*90));
const sWave=()=>[523,659,784].forEach((f,i)=>setTimeout(()=>beep(f,'square',.1,.18),i*60));
const sBull=()=>{
  // Super power-up sound effect
  // Mont√©e rapide avec harmoniques
  [200,250,315,400,500,630,800,1000,1260].forEach((f,i)=>setTimeout(()=>{
    beep(f,'triangle',.08,.25);
    beep(f*1.5,'sine',.06,.15); // Harmonic
  },i*35));
  // Explosion finale brillante
  setTimeout(()=>{
    beep(1600,'sine',.25,.3);
    beep(2400,'triangle',.2,.2);
    beep(3200,'sine',.15,.15);
  },320);
};

const sUnicornCatch=()=>{
  // Son magique et scintillant quand on attrape la licorne
  // Arp√®ge ascendant avec harmoniques brillantes
  [523, 659, 784, 988, 1175, 1397, 1661].forEach((f,i)=>setTimeout(()=>{
    beep(f,'sine',.15,.2);
    beep(f*2,'triangle',.12,.12); // Octave sup√©rieure
    beep(f*3,'sine',.08,.08); // Harmonique brillante
  },i*40));
  
  // Trille magique final
  setTimeout(()=>{
    [1661, 1976, 1661, 1976, 2093].forEach((f,i)=>setTimeout(()=>beep(f,'triangle',.08,.15),i*30));
  }, 300);
};

const sKill=()=>{
  // Son brutal et satisfaisant de destruction d'ennemi
  beep(150,'sawtooth',.15,.7,220); // Impact lourd - volume augment√©
  beep(80,'square',.18,.6); // Grognement sourd - volume augment√©
  setTimeout(()=>beep(60,'sawtooth',.12,.5),50); // √âcho de mort - volume augment√©
};

// Fonction pour l'effet visuel de mort d'ennemi
function enemyDeathEffect(x, y) {
  // Ajouter 50 points
  score += 50;
  updateScore();
  
  // PROJECTION DE SANG comme le h√©ros qui tombe
  // Sang qui gicle vers le bas et sur les c√¥t√©s
  for(let i=0; i<30; i++){
    const angle = Math.PI/2 + (Math.random()-0.5)*Math.PI*0.8; // Vers le bas principalement
    const velocity = 8 + Math.random()*12;
    const bloodColors = ['#cc0000', '#ff2200', '#880000', '#ff6666'];
    parts.push({
      x,
      y: y-40,
      vx: Math.cos(angle)*velocity,
      vy: Math.sin(angle)*velocity, // Vers le bas
      life: 60 + Math.random()*40,
      col: bloodColors[Math.floor(Math.random()*bloodColors.length)],
      sz: 4 + Math.random()*6
    });
  }
  
  // GROSSE explosion de sang avec des particules MASSIVES
  // Particules √©normes qui vont loin et durent longtemps
  for(let i=0;i<40;i++){
    const a = Math.random()*Math.PI*2;
    const v = 4 + Math.random()*14; // Vitesse TR√àS √©lev√©e pour dispersion large
    const bloodColors = ['#cc0000', '#ff2200', '#880000', '#ff6666', '#aa0000'];
    parts.push({
      x, 
      y: y-35,
      vx: Math.cos(a)*v,
      vy: Math.sin(a)*v - 3, // Vers le haut
      life: 50 + Math.random()*40, // Dur√©e TR√àS longue
      col: bloodColors[Math.floor(Math.random()*bloodColors.length)],
      sz: 5 + Math.random()*8 // Taille √âNORME (5-13px)
    });
  }
  
  // Gicl√©es de sang directionnelles VERS LE HAUT et L'ARRI√àRE (bien visibles)
  for(let i=0;i<25;i++){
    const bloodColors = ['#cc0000', '#ff2200', '#880000', '#ff6666'];
    parts.push({
      x,
      y: y-40,
      vx: -3 - Math.random()*8, // Vers l'arri√®re (gauche)
      vy: -8 - Math.random()*10, // Fort vers le haut
      life: 60 + Math.random()*30,
      col: bloodColors[Math.floor(Math.random()*bloodColors.length)],
      sz: 6 + Math.random()*10 // Tr√®s grosses gouttes
    });
  }
  
  // Particules dor√©es de l'invincibilit√© (plus petites)
  spawnParts(x, y-35, '#ffaa00', 15, 8);
  spawnParts(x, y-35, '#FFD700', 10, 7);
  
  // Son et flash
  sKill();
  flash('#ff0000', 15);
}

const sUnicornWin=()=>{
  // Son de victoire triomphant
  // Fanfare majeure ascendante
  [523, 659, 784, 1047].forEach((f,i)=>setTimeout(()=>{
    beep(f,'triangle',.2,.3);
    beep(f*1.5,'sine',.18,.2);
  },i*80));
  
  // Accord de victoire final
  setTimeout(()=>{
    beep(1047,'sine',.4,.3);
    beep(1319,'triangle',.4,.25);
    beep(1568,'sine',.4,.2);
    beep(2093,'triangle',.35,.15);
  }, 350);
  
  // Trille final scintillant
  setTimeout(()=>{
    [2093, 2349, 2637, 2793].forEach((f,i)=>setTimeout(()=>beep(f,'sine',.1,.2),i*35));
  }, 750);
};

const sUnicornLose=()=>{
  // Son de d√©faite descendant et triste
  // Arp√®ge mineur descendant
  [784, 659, 587, 523, 440, 392, 349].forEach((f,i)=>setTimeout(()=>{
    beep(f,'sine',.18,.25);
    beep(f*0.75,'triangle',.15,.15); // Note basse
  },i*70));
  
  // Note finale triste
  setTimeout(()=>{
    beep(294,'sawtooth',.5,.3);
    beep(220,'sine',.5,.2);
  }, 500);
};

const sFall=()=>{// Falling whoosh + impact
  if(!AC)return;
  const o=AC.createOscillator(),g=AC.createGain();
  o.connect(g);g.connect(AC.destination);o.type='sawtooth';
  o.frequency.setValueAtTime(400,AC.currentTime);
  o.frequency.exponentialRampToValueAtTime(40,AC.currentTime+1.2);
  g.gain.setValueAtTime(.35,AC.currentTime);
  g.gain.exponentialRampToValueAtTime(.001,AC.currentTime+1.5);
  o.start();o.stop(AC.currentTime+1.5);
  setTimeout(()=>{beep(60,'square',.4,.5);beep(80,'sawtooth',.3,.4);},1200);
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DRAW UTILS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function circle(x,y,r,c){ctx.fillStyle=c;ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();}
function ellipse2(x,y,rx,ry,c){ctx.fillStyle=c;ctx.beginPath();ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2);ctx.fill();}
function rr(x,y,w,h,r,c){ctx.fillStyle=c;ctx.beginPath();ctx.roundRect(x,y,w,h,r);ctx.fill();}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BACKGROUND
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const STARS=Array.from({length:80},()=>({rx:Math.random(),ry:Math.random()*.72,sz:.5+Math.random()*1.4,sp:.003+Math.random()*.007,ph:Math.random()*Math.PI*2}));
const MFAR=Array.from({length:11},(_,i)=>({rx:i/11,h:.19+Math.random()*.1,w:.13+Math.random()*.07}));
const MNEAR=Array.from({length:15},(_,i)=>({rx:i/15+Math.random()*.015,h:.13+Math.random()*.09,w:.09+Math.random()*.06}));
const BGTREES=Array.from({length:16},(_,i)=>({rx:i/16+Math.random()*.02,s:.5+Math.random()*.45,sp:.11+Math.random()*.07}));
const FGTREES=Array.from({length:10},(_,i)=>({rx:i/10+Math.random()*.02,s:.75+Math.random()*.55,sp:.2+Math.random()*.1}));
const TORCH_RX=Array.from({length:10},(_,i)=>i/10);
const CLOUDS=Array.from({length:7},(_,i)=>({rx:i/7+Math.random()*.1,ry:.07+Math.random()*.16,sp:.025+Math.random()*.018,w:70+Math.random()*110,h:25+Math.random()*.28}));

let F=0, camX=0, camFrozen=false, frozenCamX=0;

function drawSky(collapse){
  if(collapse){
    // void ‚Äî dark cracking look
    const g=ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#000');g.addColorStop(1,'#0a0008');
    ctx.fillStyle=g;ctx.fillRect(0,0,W,H);
    return;
  }
  
  // Define sky gradients for each phase
  const skyGradients = {
    0: { // Day
      top: '#4a9fff',
      mid1: '#6eb5ff',
      mid2: '#88c5ff',
      bottom: '#a8d5ff'
    },
    1: { // Sunset
      top: '#ff6b35',
      mid1: '#ff8c42',
      mid2: '#ffa552',
      bottom: '#ffbe76'
    },
    2: { // Night
      top: '#010110',
      mid1: '#07062a',
      mid2: '#111048',
      bottom: '#1c1660'
    },
    3: { // Sunrise
      top: '#ff9a56',
      mid1: '#ffb066',
      mid2: '#ffc589',
      bottom: '#ffd5a8'
    }
  };
  
  // Get current and target sky colors
  const currentSky = skyGradients[skyPhase];
  
  if(isTransitioning && skyTransition < 1) {
    // Blend between current and target sky
    const targetSky = skyGradients[targetSkyPhase];
    const t = skyTransition;
    
    const blend = (c1, c2, t) => {
      const r1 = parseInt(c1.slice(1,3), 16);
      const g1 = parseInt(c1.slice(3,5), 16);
      const b1 = parseInt(c1.slice(5,7), 16);
      const r2 = parseInt(c2.slice(1,3), 16);
      const g2 = parseInt(c2.slice(3,5), 16);
      const b2 = parseInt(c2.slice(5,7), 16);
      const r = Math.round(r1 + (r2 - r1) * t);
      const g = Math.round(g1 + (g2 - g1) * t);
      const b = Math.round(b1 + (b2 - b1) * t);
      return `rgb(${r},${g},${b})`;
    };
    
    const g = ctx.createLinearGradient(0,0,0,GY+10);
    g.addColorStop(0, blend(currentSky.top, targetSky.top, t));
    g.addColorStop(.4, blend(currentSky.mid1, targetSky.mid1, t));
    g.addColorStop(.78, blend(currentSky.mid2, targetSky.mid2, t));
    g.addColorStop(1, blend(currentSky.bottom, targetSky.bottom, t));
    ctx.fillStyle=g;ctx.fillRect(0,0,W,GY+10);
  } else {
    // No transition, use current sky
    const g = ctx.createLinearGradient(0,0,0,GY+10);
    g.addColorStop(0, currentSky.top);
    g.addColorStop(.4, currentSky.mid1);
    g.addColorStop(.78, currentSky.mid2);
    g.addColorStop(1, currentSky.bottom);
    ctx.fillStyle=g;ctx.fillRect(0,0,W,GY+10);
  }
}
function drawStars(){
  // Only show stars during night (phase 2) and transitions involving night
  let starAlpha = 0;
  if(skyPhase === 2) {
    starAlpha = 1;
  } else if(isTransitioning) {
    if(targetSkyPhase === 2) {
      starAlpha = skyTransition; // Fade in
    } else if(skyPhase === 2) {
      starAlpha = 1 - skyTransition; // Fade out
    }
  }
  
  if(starAlpha <= 0) return;
  
  STARS.forEach(s=>{
    const x=((s.rx*W*3-camX*s.sp*.5)%(W*3)+W*3)%W;if(x>W)return;
    const a=(.38+Math.sin(F*.05+s.ph)*.32) * starAlpha;
    ctx.globalAlpha=a;ctx.fillStyle='#e0dcff';ctx.fillRect(x|0,(s.ry*H)|0,s.sz,s.sz);
  });ctx.globalAlpha=1;
}
function drawMoon(){
  // Only show moon during night (phase 2) and transitions involving night
  let moonAlpha = 0;
  if(skyPhase === 2) {
    moonAlpha = 1;
  } else if(isTransitioning) {
    if(targetSkyPhase === 2) {
      moonAlpha = skyTransition;
    } else if(skyPhase === 2) {
      moonAlpha = 1 - skyTransition;
    }
  }
  
  if(moonAlpha <= 0) return;
  
  const mx=((W*.78-camX*.002)%(W*5)+W*5)%W,my=H*.09;
  ctx.globalAlpha = moonAlpha * 0.13;
  const g=ctx.createRadialGradient(mx,my,10,mx,my,80);g.addColorStop(0,'rgba(230,220,170,1)');g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(mx,my,80,0,Math.PI*2);ctx.fill();
  ctx.globalAlpha = moonAlpha;
  ctx.fillStyle='#f2eec6';ctx.beginPath();ctx.arc(mx,my,34,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#fffadc';ctx.beginPath();ctx.arc(mx-4,my-4,27,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#e4dc98';ctx.beginPath();ctx.arc(mx+11,my+7,7,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#d8d080';ctx.beginPath();ctx.arc(mx-9,my+9,4,0,Math.PI*2);ctx.fill();
  ctx.globalAlpha=1;
}
function drawSun(){
  // Show sun during day (0), sunset (1), and sunrise (3)
  let sunAlpha = 0;
  let sunY = H*.12; // Default position
  
  if(skyPhase === 0) {
    sunAlpha = 1;
    sunY = H*.12; // High in sky
  } else if(skyPhase === 1) {
    sunAlpha = 1;
    sunY = H*.35; // Lower for sunset
  } else if(skyPhase === 3) {
    sunAlpha = 1;
    sunY = H*.38; // Lower for sunrise
  } else if(isTransitioning) {
    if(targetSkyPhase === 0 || targetSkyPhase === 1 || targetSkyPhase === 3) {
      sunAlpha = skyTransition;
    } else if(skyPhase === 0 || skyPhase === 1 || skyPhase === 3) {
      sunAlpha = 1 - skyTransition;
    }
    // Interpolate position during transition
    if(skyPhase === 0 && targetSkyPhase === 1) {
      sunY = H*.12 + (H*.35 - H*.12) * skyTransition;
    } else if(skyPhase === 3 && targetSkyPhase === 0) {
      sunY = H*.38 + (H*.12 - H*.38) * skyTransition;
    }
  }
  
  if(sunAlpha <= 0) return;
  
  const sx=((W*.75-camX*.003)%(W*5)+W*5)%W;
  
  // Sun glow
  ctx.globalAlpha = sunAlpha * 0.2;
  const g=ctx.createRadialGradient(sx,sunY,15,sx,sunY,100);
  g.addColorStop(0,'rgba(255,230,100,1)');
  g.addColorStop(.5,'rgba(255,180,50,.5)');
  g.addColorStop(1,'rgba(255,130,0,0)');
  ctx.fillStyle=g;ctx.beginPath();ctx.arc(sx,sunY,100,0,Math.PI*2);ctx.fill();
  
  // Sun disc
  ctx.globalAlpha = sunAlpha;
  ctx.fillStyle='#ffe866';ctx.beginPath();ctx.arc(sx,sunY,38,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#fff9aa';ctx.beginPath();ctx.arc(sx-5,sunY-5,30,0,Math.PI*2);ctx.fill();
  ctx.globalAlpha=1;
}
function drawClouds(){
  ctx.globalAlpha=.16;
  CLOUDS.forEach(cl=>{
    const x=((cl.rx*W*3-camX*cl.sp*.35)%(W*3)+W*3)%W,y=cl.ry*H;
    ctx.fillStyle='#7880c0';
    ctx.beginPath();ctx.ellipse(x,y,cl.w*.48,cl.h*.38,0,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.ellipse(x-cl.w*.18,y+cl.h*.1,cl.w*.32,cl.h*.28,0,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.ellipse(x+cl.w*.18,y+cl.h*.1,cl.w*.28,cl.h*.28,0,0,Math.PI*2);ctx.fill();
  });ctx.globalAlpha=1;
}
function drawMtnFar(){
  ctx.fillStyle='#0b0921';
  MFAR.forEach(m=>{
    const bw=m.w*W*2,x=((m.rx*W*2-camX*.038)%(W*2)+W*2)%W,mh=m.h*H;
    ctx.beginPath();ctx.moveTo(x-bw*.5,GY+2);ctx.lineTo(x,GY-mh);ctx.lineTo(x+bw*.5,GY+2);ctx.fill();
    ctx.fillStyle='#c8c4e0';ctx.beginPath();ctx.moveTo(x-bw*.08,GY-mh+mh*.17);ctx.lineTo(x,GY-mh);ctx.lineTo(x+bw*.08,GY-mh+mh*.17);ctx.fill();
    ctx.fillStyle='#0b0921';
  });
}
function drawMtnNear(){
  ctx.fillStyle='#0e0c26';
  MNEAR.forEach(m=>{
    const bw=m.w*W*2,x=((m.rx*W*2+W*.04-camX*.085)%(W*2)+W*2)%W,mh=m.h*H;
    ctx.beginPath();ctx.moveTo(x-bw*.5,GY+2);ctx.lineTo(x,GY-mh);ctx.lineTo(x+bw*.5,GY+2);ctx.fill();
  });
}
function drawTree(x,y,sc,dark){
  const s=sc;
  ctx.fillStyle=dark?'#18090a':'#483010';rr(x-5*s,y-20*s,10*s,20*s,2,'');
  const gs=dark?['#09120a','#0b160a','#0d1b0c']:['#185c14','#207e1e','#28902a','#44aa2c'];
  ctx.fillStyle=gs[0];ctx.beginPath();ctx.ellipse(x,y-40*s,22*s,26*s,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle=gs[1];ctx.beginPath();ctx.ellipse(x,y-52*s,17*s,20*s,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle=gs[2];ctx.beginPath();ctx.ellipse(x,y-62*s,11*s,13*s,0,0,Math.PI*2);ctx.fill();
  if(!dark){ctx.fillStyle=gs[3];ctx.beginPath();ctx.ellipse(x-3*s,y-68*s,7*s,9*s,-.3,0,Math.PI*2);ctx.fill();}
}
function drawBGTrees(){BGTREES.forEach(t=>{const x=((t.rx*W*2.5-camX*t.sp)%(W*2.5)+W*2.5)%W;if(x>W+70)return;drawTree(x,GY,t.s*.62,true);});}
function drawFGTrees(){FGTREES.forEach(t=>{const x=((t.rx*W*2.2-camX*t.sp)%(W*2.2)+W*2.2)%W;if(x>W+70)return;drawTree(x,GY,t.s*.82,false);});}
function drawTorches(){
  // Calculate torch brightness based on sky phase
  let torchBrightness = 1;
  
  if(skyPhase === 0) {
    // Day - torches are off
    torchBrightness = 0;
  } else if(skyPhase === 3) {
    // Sunrise - dim torches
    torchBrightness = 0.4;
  } else if(skyPhase === 1) {
    // Sunset - medium brightness
    torchBrightness = 0.7;
  } else if(skyPhase === 2) {
    // Night - full brightness
    torchBrightness = 1;
  }
  
  // During transitions
  if(isTransitioning) {
    if(targetSkyPhase === 0) {
      // Transitioning to day - fade out
      torchBrightness = torchBrightness * (1 - skyTransition);
    } else if(skyPhase === 0) {
      // Transitioning from day - fade in
      torchBrightness = torchBrightness * skyTransition;
    }
  }
  
  TORCH_RX.forEach(rx=>{
    const x=((rx*W*2.5-camX*.33)%(W*2.5)+W*2.5)%W;if(x>W+28)return;
    // Draw torch post (always visible)
    ctx.fillStyle='#381807';rr(x-4,GY-58,9,58,2,'#381807');rr(x-3,GY-57,6,52,2,'#583018');
    ctx.fillStyle='#281408';rr(x-7,GY-64,14,9,2,'#281408');
    
    // Draw flame only if brightness > 0
    if(torchBrightness > 0) {
      const fl=Math.sin(F*.14+rx*18)*2;
      ctx.globalAlpha = torchBrightness;
      ctx.fillStyle='#ff3e00';ctx.beginPath();ctx.ellipse(x+fl,GY-78,7,14,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#ff7e00';ctx.beginPath();ctx.ellipse(x+fl*.7,GY-80,5,10,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#ffbb00';ctx.beginPath();ctx.ellipse(x+fl*.3,GY-82,3,7,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#fffacc';circle(x+fl*.2,GY-84,2,'#fffacc');
      const gg=ctx.createRadialGradient(x,GY-75,3,x,GY-75,32);gg.addColorStop(0,`rgba(255,130,0,${.22*torchBrightness})`);gg.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=gg;ctx.beginPath();ctx.arc(x,GY-75,32,0,Math.PI*2);ctx.fill();
      ctx.globalAlpha = 1;
    }
  });
}
function drawGround(cracking, fallOffset){
  if(cracking){
    // Ground splits and falls
    const g=ctx.createLinearGradient(0,GY+fallOffset,0,H);
    g.addColorStop(0,'#1a0808');g.addColorStop(1,'#050203');
    ctx.fillStyle=g;ctx.fillRect(0,GY+fallOffset,W,H);
    ctx.fillStyle='#2c4a1c';ctx.fillRect(0,GY+fallOffset,W,7);
    // cracks
    ctx.strokeStyle='#000';ctx.lineWidth=3;
    for(let i=0;i<6;i++){
      const cx=W*.1+i*(W*.16);
      ctx.beginPath();ctx.moveTo(cx,GY+fallOffset);ctx.lineTo(cx+20,GY+fallOffset+40);ctx.lineTo(cx-10,GY+fallOffset+80);ctx.stroke();
    }
    return;
  }
  const g2=ctx.createLinearGradient(0,GY,0,H);
  g2.addColorStop(0,'#2a5818');g2.addColorStop(.05,'#47301a');g2.addColorStop(.2,'#372507');g2.addColorStop(1,'#181004');
  ctx.fillStyle=g2;ctx.fillRect(0,GY,W,H-GY);
  ctx.fillStyle='#386a24';ctx.fillRect(0,GY,W,8);
  ctx.fillStyle='#489630';ctx.fillRect(0,GY,W,4);
  ctx.fillStyle='#54ae36';ctx.fillRect(0,GY,W,2);
  for(let i=0;i<38;i++){
    const gx=((i*64+26-camX*.48)%(W+120)+W+120)%W;
    ctx.fillStyle='#387a1e';ctx.beginPath();ctx.moveTo(gx,GY);ctx.lineTo(gx+3,GY-7);ctx.lineTo(gx+5,GY);ctx.fill();
    ctx.fillStyle='#489626';ctx.beginPath();ctx.moveTo(gx+7,GY);ctx.lineTo(gx+9,GY-9);ctx.lineTo(gx+12,GY);ctx.fill();
    ctx.fillStyle='#58ac2e';ctx.beginPath();ctx.moveTo(gx+3,GY);ctx.lineTo(gx+5,GY-5);ctx.lineTo(gx+7,GY);ctx.fill();
  }
}
function drawPlatform(pl){
  const sx=pl.x-camX;if(sx<-200||sx>W+200)return;
  ctx.globalAlpha=.18;ellipse2(sx+pl.w/2,GY+7,pl.w/2+4,7,'#000');ctx.globalAlpha=1;
  const pg=ctx.createLinearGradient(sx,pl.y,sx,pl.y+20);pg.addColorStop(0,'#489830');pg.addColorStop(.15,'#387618');pg.addColorStop(.3,'#684818');pg.addColorStop(1,'#382408');
  ctx.fillStyle=pg;ctx.beginPath();ctx.roundRect(sx,pl.y,pl.w,20,5);ctx.fill();
  ctx.fillStyle='#54b436';ctx.beginPath();ctx.roundRect(sx+2,pl.y,pl.w-4,5,3);ctx.fill();
  ctx.fillStyle='#64c840';ctx.beginPath();ctx.roundRect(sx+4,pl.y,pl.w-8,3,2);ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.25)';ctx.lineWidth=1.5;ctx.beginPath();ctx.roundRect(sx,pl.y,pl.w,20,5);ctx.stroke();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RACCOON ‚Äî uses uploaded sprite frames (blend to remove black)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const HERO_W=52, HERO_H=78; // collision box
function drawRaccoon(cx,cy,frameIdx,inv,falling,fallVel){
  if(inv&&(F>>2)&1)return; // flicker when invincible
  if(assetsLoaded<2){
    // Fallback: draw simple cartoon
    ctx.fillStyle='#8a6040';circle(cx,cy-40,22,'#a07050');
    ctx.fillStyle='#444';circle(cx,cy-44,8,'#333');circle(cx-8,cy-36,6,'#333');
    return;
  }
  const fi = frameIdx % 2;
  const img = raccoonFrames[fi];
  // Scale to consistent size (~90px tall)
  const targetH = 90;
  const targetW = (img.naturalWidth / img.naturalHeight) * targetH;
  const drawX = cx - targetW/2;
  const drawY = cy - targetH; // feet at cy
  ctx.save();
  if(falling){ctx.rotate(.3);} // tilt when falling
  // Use "screen" blending to remove black background
  ctx.globalCompositeOperation = 'source-over';
  if(inv){ctx.filter='brightness(2) sepia(1) hue-rotate(20deg)';}
  ctx.drawImage(img, drawX, drawY, targetW, targetH);
  ctx.filter='none';
  ctx.restore();
  // Golden aura when invincible
  if(inv){
    const a=ctx.createRadialGradient(cx,cy-45,10,cx,cy-45,55);
    a.addColorStop(0,'rgba(255,200,0,.3)');a.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=a;ctx.beginPath();ctx.arc(cx,cy-45,55,0,Math.PI*2);ctx.fill();
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BEAR ENEMY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawBear(sx,sy,frame){
  const t=frame/7*Math.PI*2;
  const hop=Math.abs(Math.sin(t))*7;
  const x=sx,y=sy-hop;
  const run=Math.sin(t);
  ctx.globalAlpha=.14;ellipse2(x,sy+2,20,5,'#000');ctx.globalAlpha=1;
  // legs
  [-1,1].forEach(side=>{
    const la=run*side*10;
    ctx.fillStyle='#5a3018';ctx.beginPath();ctx.ellipse(x+side*9,y-9,7,11,la*.03,0,Math.PI*2);ctx.fill();
    rr(x+side*9+la*.5-8,y+2,16,8,3,'#2a1208');
  });
  // body
  ctx.fillStyle='#6a3c20';ctx.beginPath();ctx.ellipse(x,y-26,20,24,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#c0906a';ctx.beginPath();ctx.ellipse(x,y-22,12,16,0,0,Math.PI*2);ctx.fill();
  // arms
  ctx.fillStyle='#6a3c20';ctx.beginPath();ctx.ellipse(x+18,y-28,8,11,.3,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.ellipse(x-18,y-28,8,11,-.3,0,Math.PI*2);ctx.fill();
  // head
  ctx.fillStyle='#6a3c20';circle(x,y-48,20,'#6a3c20');
  ctx.fillStyle='#7a4c2c';circle(x,y-50,16,'#7a4c2c');
  // snout
  ctx.fillStyle='#c0906a';ctx.beginPath();ctx.ellipse(x,y-44,10,8,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#2a1208';ctx.beginPath();ctx.ellipse(x,y-42,4,3,0,0,Math.PI*2);ctx.fill();
  // eyes
  circle(x-7,y-50,5,'#fff');circle(x+7,y-50,5,'#fff');
  circle(x-6,y-50,3,'#2a1208');circle(x+8,y-50,3,'#2a1208');
  circle(x-5,y-51,1.4,'#fff');circle(x+9,y-51,1.4,'#fff');
  // ears
  ctx.fillStyle='#5a3018';ctx.beginPath();ctx.arc(x-15,y-62,9,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(x+15,y-62,9,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#c08060';ctx.beginPath();ctx.arc(x-15,y-62,5,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(x+15,y-62,5,0,Math.PI*2);ctx.fill();
  // angry brow
  ctx.strokeStyle='#2a1208';ctx.lineWidth=2.5;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(x-12,y-56);ctx.lineTo(x-3,y-54);ctx.stroke();
  ctx.beginPath();ctx.moveTo(x+12,y-56);ctx.lineTo(x+3,y-54);ctx.stroke();
}

function drawKnight(sx,sy,frame){
  const t=frame/7*Math.PI*2;
  const hop=Math.abs(Math.sin(t))*7;
  const x=sx,y=sy-hop;
  const run=Math.sin(t);
  
  // Shadow (plus grande)
  ctx.globalAlpha=.14;ellipse2(x,sy+2,24,6,'#000');ctx.globalAlpha=1;
  
  // Legs (armored) - plus grandes
  [-1,1].forEach(side=>{
    const la=run*side*10;
    ctx.fillStyle='#606570';ctx.beginPath();ctx.ellipse(x+side*10,y-12,8,14,la*.03,0,Math.PI*2);ctx.fill();
    rr(x+side*10+la*.5-8,y+3,16,10,3,'#404550');
  });
  
  // Body (armor chest plate) - plus grand
  ctx.fillStyle='#707888';ctx.beginPath();ctx.ellipse(x,y-35,22,28,0,0,Math.PI*2);ctx.fill();
  // Chest plate highlights
  ctx.fillStyle='#8090a0';ctx.beginPath();ctx.ellipse(x-4,y-38,11,20,0,0,Math.PI*2);ctx.fill();
  
  // Arms (armored) - plus grandes
  ctx.fillStyle='#606570';ctx.beginPath();ctx.ellipse(x+20,y-38,9,14,.3,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.ellipse(x-20,y-38,9,14,-.3,0,Math.PI*2);ctx.fill();
  
  // Sword in right hand - plus grande
  ctx.fillStyle='#a0a8b0';rr(x+27,y-42,4,26,1,'#a0a8b0');
  ctx.fillStyle='#8b7355';rr(x+26,y-18,6,8,2,'#8b7355'); // hilt
  ctx.fillStyle='#d4af37';rr(x+24,y-13,10,3,1,'#d4af37'); // guard
  
  // Helmet - plus grand
  ctx.fillStyle='#707888';circle(x,y-62,22,'#707888');
  // Helmet shine
  ctx.fillStyle='#8898a8';ctx.beginPath();ctx.ellipse(x-5,y-65,8,14,0,0,Math.PI*2);ctx.fill();
  // Visor slit (dark) - plus large
  ctx.fillStyle='#1a1820';rr(x-14,y-62,28,7,2,'#1a1820');
  // Eye glow through visor - plus espac√©s
  ctx.fillStyle='#ff4444';circle(x-7,y-62,2.5,'#ff4444');circle(x+7,y-62,2.5,'#ff4444');
  
  // Helmet plume/crest - plus grand
  ctx.fillStyle='#cc3333';
  ctx.beginPath();
  ctx.moveTo(x,y-80);
  ctx.lineTo(x-6,y-72);
  ctx.lineTo(x-3,y-76);
  ctx.lineTo(x,y-68);
  ctx.lineTo(x+3,y-76);
  ctx.lineTo(x+6,y-72);
  ctx.closePath();
  ctx.fill();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GOLDEN BULL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawBull(sx,sy,t){
  const pulse=.7+Math.sin(t*.08)*.3;
  const x=sx,y=sy;
  // Aura glow
  const ag=ctx.createRadialGradient(x,y-35,10,x,y-35,80);
  ag.addColorStop(0,`rgba(255,200,0,${.5*pulse})`);ag.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=ag;ctx.beginPath();ctx.arc(x,y-35,80,0,Math.PI*2);ctx.fill();
  // legs
  [-14,-4,4,14].forEach((ox,i)=>{
    const trot=Math.sin(t*.12+i*1.2)*.15;
    ctx.fillStyle='#cc8800';ctx.save();ctx.translate(x+ox,y-12);ctx.rotate(trot);
    ctx.beginPath();ctx.ellipse(0,0,7,13,0,0,Math.PI*2);ctx.fill();
    ctx.restore();
    rr(x+ox-6,y-1,12,7,2,'#886600');
  });
  // body ‚Äî big and powerful
  const bg=ctx.createLinearGradient(x-34,y-55,x+34,y-15);
  bg.addColorStop(0,'#ffe040');bg.addColorStop(.5,'#cc9000');bg.addColorStop(1,'#886000');
  ctx.fillStyle=bg;ctx.beginPath();ctx.ellipse(x,y-34,34,24,0,0,Math.PI*2);ctx.fill();
  // shine
  ctx.fillStyle='rgba(255,255,200,.25)';ctx.beginPath();ctx.ellipse(x-8,y-44,14,8,-.3,0,Math.PI*2);ctx.fill();
  // neck
  ctx.fillStyle='#cc9000';ctx.beginPath();ctx.ellipse(x-20,y-48,14,18,-.3,0,Math.PI*2);ctx.fill();
  // head
  const hg=ctx.createLinearGradient(x-44,y-68,x-14,y-42);
  hg.addColorStop(0,'#ffe040');hg.addColorStop(1,'#aa7800');
  ctx.fillStyle=hg;ctx.beginPath();ctx.ellipse(x-30,y-58,20,17,0,0,Math.PI*2);ctx.fill();
  // snout
  ctx.fillStyle='#bb8800';ctx.beginPath();ctx.ellipse(x-44,y-54,10,8,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#000';ctx.beginPath();ctx.ellipse(x-44,y-54,4,3,0,0,Math.PI*2);ctx.fill();
  // eye
  circle(x-24,y-62,6,'#fff');circle(x-23,y-62,4,'#000');circle(x-22,y-63,1.5,'#fff');
  // angry brow
  ctx.strokeStyle='#664400';ctx.lineWidth=3;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(x-36,y-70);ctx.lineTo(x-24,y-66);ctx.stroke();
  // HORNS ‚Äî curved
  ctx.strokeStyle='#eee0a0';ctx.lineWidth=5;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(x-20,y-72);ctx.quadraticCurveTo(x-12,y-90,x-6,y-80);ctx.stroke();
  ctx.beginPath();ctx.moveTo(x-34,y-72);ctx.quadraticCurveTo(x-38,y-90,x-30,y-82);ctx.stroke();
  ctx.strokeStyle='#fff8d0';ctx.lineWidth=2;
  ctx.beginPath();ctx.moveTo(x-21,y-72);ctx.quadraticCurveTo(x-13,y-88,x-7,y-79);ctx.stroke();
  // tail
  ctx.strokeStyle='#cc9000';ctx.lineWidth=4;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(x+33,y-38);ctx.quadraticCurveTo(x+46,y-48,x+40,y-56);ctx.stroke();
  ctx.strokeStyle='#ffe040';ctx.lineWidth=2;
  ctx.beginPath();ctx.moveTo(x+33,y-38);ctx.quadraticCurveTo(x+45,y-47,x+40,y-54);ctx.stroke();
  // star sparkles
  for(let i=0;i<4;i++){
    const sa=(F*.1+i*1.57)%(Math.PI*2);
    const sx2=x+Math.cos(sa)*52,sy2=y-38+Math.sin(sa)*38;
    ctx.fillStyle=`rgba(255,255,150,${.7*pulse})`;
    ctx.beginPath();ctx.moveTo(sx2,sy2-4);ctx.lineTo(sx2+2,sy2-1);ctx.lineTo(sx2+5,sy2);ctx.lineTo(sx2+2,sy2+1);ctx.lineTo(sx2,sy2+4);ctx.lineTo(sx2-2,sy2+1);ctx.lineTo(sx2-5,sy2);ctx.lineTo(sx2-2,sy2-1);ctx.closePath();ctx.fill();
  }
  // label
  ctx.font='bold 9px "Press Start 2P"';ctx.textAlign='center';ctx.fillStyle='#fff8a0';ctx.shadowColor='#ff8800';ctx.shadowBlur=10;
  ctx.fillText('‚ö°',x-28,y-88);ctx.shadowBlur=0;
}

function drawUnicorn(sx,sy,t,trail){
  const x=sx,y=sy;
  const float = Math.sin(t*.08)*8;
  const actualY = y + float;
  
  // Dessiner la tra√Æn√©e arc-en-ciel
  if(trail && trail.length > 0) {
    for(let i=0; i<trail.length-1; i++) {
      const tp = trail[i];
      const alpha = 1 - (i / trail.length);
      const hue = (t*5 + i*10) % 360;
      ctx.globalAlpha = alpha * 0.6;
      ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
      ctx.lineWidth = 12 - (i/trail.length)*8;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(tp.x - camX, tp.y);
      if(i < trail.length - 1) {
        ctx.lineTo(trail[i+1].x - camX, trail[i+1].y);
      }
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }
  
  // Aura magique
  const auraGrad=ctx.createRadialGradient(x,actualY,0,x,actualY,60);
  auraGrad.addColorStop(0,'rgba(255,150,255,.4)');
  auraGrad.addColorStop(.5,'rgba(150,200,255,.2)');
  auraGrad.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=auraGrad;
  ctx.beginPath();ctx.arc(x,actualY,60,0,Math.PI*2);ctx.fill();
  
  // Corps
  ctx.fillStyle='#fff';
  ctx.beginPath();ctx.ellipse(x,actualY,28,20,0,0,Math.PI*2);ctx.fill();
  
  // Pattes
  const legPositions = [-12,-4,4,12];
  legPositions.forEach((lx,i)=>{
    const legMove = Math.sin(t*.15 + i*1.5)*5;
    ctx.fillStyle='#fff';
    ctx.beginPath();ctx.ellipse(x+lx,actualY+15+legMove,5,10,0,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='#FFD700';
    rr(x+lx-4,actualY+23+legMove,8,5,2,'#FFD700');
  });
  
  // T√™te
  ctx.fillStyle='#fff';
  ctx.beginPath();ctx.ellipse(x-22,actualY-12,16,14,-.3,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#ffe0f0';
  ctx.beginPath();ctx.ellipse(x-34,actualY-8,8,6,0,0,Math.PI*2);ctx.fill();
  circle(x-18,actualY-14,5,'#000');
  circle(x-17,actualY-15,2,'#fff');
  
  // Corne arc-en-ciel
  const hornGrad=ctx.createLinearGradient(x-20,actualY-32,x-20,actualY-18);
  hornGrad.addColorStop(0,'#ff88ff');
  hornGrad.addColorStop(.3,'#88ddff');
  hornGrad.addColorStop(.6,'#ffff88');
  hornGrad.addColorStop(1,'#ff88aa');
  ctx.fillStyle=hornGrad;
  ctx.beginPath();
  ctx.moveTo(x-18,actualY-18);
  ctx.lineTo(x-22,actualY-18);
  ctx.lineTo(x-20,actualY-35);
  ctx.closePath();
  ctx.fill();
  
  // Crini√®re et queue arc-en-ciel
  for(let i=0; i<5; i++) {
    const hue = (t*3 + i*60) % 360;
    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
    const mx = x-8+i*3;
    const my = actualY-16-i*2;
    ctx.beginPath();
    ctx.moveTo(mx,my);
    ctx.quadraticCurveTo(mx+8,my-8,mx+6,my+6);
    ctx.quadraticCurveTo(mx+3,my+2,mx,my);
    ctx.fill();
  }
  
  // Queue
  for(let i=0; i<4; i++) {
    const hue = (t*3 + i*80) % 360;
    ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
    ctx.lineWidth = 6-i;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x+26,actualY);
    ctx.quadraticCurveTo(x+38+i*2,actualY-8+i*3,x+32+i*3,actualY+8+i*2);
    ctx.stroke();
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PORTAL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawPortal(sx,sy,t){
  const pulse=.65+Math.sin(t*.1)*.35, blink=Math.sin(t*.18)>0;
  const x=sx,y=sy;
  const ag=ctx.createRadialGradient(x,y,10,x,y,120);
  ag.addColorStop(0,`rgba(153,69,255,${.38*pulse})`);ag.addColorStop(.4,`rgba(20,241,149,${.18*pulse})`);ag.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=ag;ctx.beginPath();ctx.arc(x,y,120,0,Math.PI*2);ctx.fill();
  const pg=ctx.createLinearGradient(x-52,0,x-36,0);pg.addColorStop(0,'#440080');pg.addColorStop(.4,'#7030c0');pg.addColorStop(1,'#440080');
  rr(x-54,y-118,19,122,5,pg);rr(x-52,y-116,5,118,3,'rgba(255,255,255,.1)');
  const pg2=ctx.createLinearGradient(x+36,0,x+54,0);pg2.addColorStop(0,'#440080');pg2.addColorStop(.6,'#7030c0');pg2.addColorStop(1,'#440080');
  rr(x+35,y-118,19,122,5,pg2);
  if(blink){[-113,-88,-63,-38].forEach(oy=>{circle(x-44,y+oy,4,'#14F195');ctx.fillStyle=`rgba(20,241,149,${.4*pulse})`;ctx.beginPath();ctx.arc(x-44,y+oy,8,0,Math.PI*2);ctx.fill();circle(x+44,y+oy,4,'#14F195');ctx.fillStyle=`rgba(20,241,149,${.4*pulse})`;ctx.beginPath();ctx.arc(x+44,y+oy,8,0,Math.PI*2);ctx.fill();});}
  const archG=ctx.createLinearGradient(x-54,y-128,x+54,y-120);archG.addColorStop(0,'#440080');archG.addColorStop(.5,'#9030e8');archG.addColorStop(1,'#440080');
  rr(x-54,y-130,108,16,7,archG);rr(x-50,y-128,100,6,3,'rgba(255,255,255,.1)');
  circle(x-45,y-122,6,'#9945FF');circle(x+45,y-122,6,'#9945FF');circle(x,y-128,7,'#14F195');
  ctx.save();ctx.beginPath();ctx.ellipse(x,y-58,32,55,0,0,Math.PI*2);ctx.clip();
  ctx.fillStyle=`rgba(55,8,115,${.82*pulse})`;ctx.fillRect(x-36,y-116,72,118);
  for(let r=6;r>=0;r--){const a=(.18+r*.06)*pulse,hue=((F*2.5+r*44))%360;ctx.strokeStyle=`hsla(${hue},100%,62%,${a})`;ctx.lineWidth=2.5;ctx.beginPath();ctx.ellipse(x,y-58,5+r*4,9+r*7,0,0,Math.PI*2);ctx.stroke();}
  const cc=ctx.createRadialGradient(x,y-58,0,x,y-58,18);cc.addColorStop(0,`rgba(190,140,255,${.45*pulse})`);cc.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=cc;ctx.beginPath();ctx.arc(x,y-58,18,0,Math.PI*2);ctx.fill();
  ctx.restore();
  ctx.font='bold 13px "Press Start 2P"';ctx.textAlign='center';ctx.fillStyle='#fff';ctx.shadowColor='#14F195';ctx.shadowBlur=14;ctx.fillText('√ó'+multip.toFixed(2),x,y-52);ctx.shadowBlur=0;
  ctx.font='7px "Press Start 2P"';ctx.fillStyle='rgba(20,241,149,.75)';ctx.fillText('CASH OUT',x,y-34);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// OBSTACLES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawObs(obj){
  const sx=obj.x-camX,y=GY;
  switch(obj.type){
    case 'rock':{const g=ctx.createLinearGradient(sx,y-58,sx,y);g.addColorStop(0,'#686088');g.addColorStop(1,'#38325e');ctx.fillStyle=g;ctx.beginPath();ctx.ellipse(sx,y-29,28,30,0,0,Math.PI*2);ctx.fill();ctx.fillStyle='rgba(255,255,255,.1)';ctx.beginPath();ctx.ellipse(sx-7,y-44,10,7,-.4,0,Math.PI*2);ctx.fill();}break;
    case 'tallrock':{const g=ctx.createLinearGradient(sx,y-95,sx,y);g.addColorStop(0,'#686088');g.addColorStop(1,'#38325e');ctx.fillStyle=g;ctx.beginPath();ctx.ellipse(sx,y-48,18,50,0,0,Math.PI*2);ctx.fill();}break;
    case 'spike':{rr(sx-42,y-4,84,7,2,'#424054');for(let i=0;i<5;i++){const ox=-34+i*17;const sg=ctx.createLinearGradient(sx+ox,y-58,sx+ox+7,y);sg.addColorStop(0,'#b8b0c8');sg.addColorStop(1,'#5e5c78');ctx.fillStyle=sg;ctx.beginPath();ctx.moveTo(sx+ox,y-2);ctx.lineTo(sx+ox+7,y-2);ctx.lineTo(sx+ox+3,y-58);ctx.closePath();ctx.fill();ctx.fillStyle='rgba(255,255,255,.28)';ctx.beginPath();ctx.moveTo(sx+ox+1,y-2);ctx.lineTo(sx+ox+3,y-58);ctx.lineTo(sx+ox+3,y-38);ctx.closePath();ctx.fill();}}break;
    case 'barrel':{const bg=ctx.createLinearGradient(sx-19,0,sx+19,0);bg.addColorStop(0,'#381607');bg.addColorStop(.5,'#784418');bg.addColorStop(1,'#381607');rr(sx-21,y-54,42,54,7,bg);ctx.fillStyle='rgba(255,255,255,.07)';rr(sx-19,y-52,17,48,5,'rgba(255,255,255,.07)');['#a8a8a8','#888888'].forEach((c,i)=>{ctx.fillStyle=c;ctx.fillRect(sx-23,y-44+i*17,46,4);});}break;
    case 'fence':{ctx.fillStyle='#672e07';ctx.fillRect(sx-38,y-22,76,5);ctx.fillRect(sx-38,y-9,76,5);for(let i=0;i<5;i++){const px=sx-38+i*19;rr(px,y-44,9,44,2,'#884e18');rr(px+1,y-42,6,38,2,'#a86228');rr(px+1,y-44,7,5,2,'#672e07');}}break;
    case 'tombstone':{const tg=ctx.createLinearGradient(sx,y-78,sx,y);tg.addColorStop(0,'#8a8aa0');tg.addColorStop(1,'#585872');rr(sx-21,y-78,42,78,4,tg);rr(sx-21,y-92,42,20,18,tg);ctx.fillStyle='rgba(255,255,255,.09)';rr(sx-17,y-90,15,64,2,'rgba(255,255,255,.09)');ctx.strokeStyle='#686880';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(sx,y-86);ctx.lineTo(sx,y-46);ctx.stroke();ctx.beginPath();ctx.moveTo(sx-11,y-68);ctx.lineTo(sx+11,y-68);ctx.stroke();}break;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COIN
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawCoin(sx,sy,t){
  const bob=Math.sin(t*.08)*5,spin=Math.cos(t*.1),x=sx,y=sy+bob;
  ctx.save();ctx.translate(x,y);ctx.scale(spin,1);
  const cg=ctx.createRadialGradient(-3,-3,1,0,0,13);cg.addColorStop(0,'#fff898');cg.addColorStop(.4,'#FFD700');cg.addColorStop(1,'#b05c00');
  circle(0,0,13,cg);ctx.fillStyle='rgba(255,255,255,.28)';ctx.beginPath();ctx.ellipse(-3,-3,5,4,-.4,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#a05800';ctx.font='bold 12px sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText('$',0,1);
  ctx.restore();
}

function drawFireball(sx,sy,t){
  const x=sx,y=sy;
  
  // Flammes anim√©es
  const flicker1 = Math.sin(t*.3)*2;
  const flicker2 = Math.cos(t*.4)*2;
  
  // Lueur externe
  ctx.globalAlpha=.3;
  const glowGrad=ctx.createRadialGradient(x,y,0,x,y,25);
  glowGrad.addColorStop(0,'rgba(255,150,0,.8)');
  glowGrad.addColorStop(1,'rgba(255,0,0,0)');
  ctx.fillStyle=glowGrad;
  ctx.beginPath();ctx.arc(x,y,25,0,Math.PI*2);ctx.fill();
  ctx.globalAlpha=1;
  
  // Boule de feu principale
  const fireGrad=ctx.createRadialGradient(x-3,y-3,2,x,y,12+flicker1);
  fireGrad.addColorStop(0,'#fff');
  fireGrad.addColorStop(.3,'#ffff00');
  fireGrad.addColorStop(.6,'#ff8800');
  fireGrad.addColorStop(1,'#ff0000');
  circle(x,y,12+flicker1,fireGrad);
  
  // Flammes secondaires
  ctx.globalAlpha=.7;
  circle(x-5+flicker2,y-5,6,'#ff8800');
  circle(x+5-flicker2,y+5,5,'#ff4400');
  ctx.globalAlpha=1;
  
  // √âtincelles
  for(let i=0;i<3;i++){
    const angle = (t*.2 + i*2.1) % (Math.PI*2);
    const dist = 8 + Math.sin(t*.15 + i)*3;
    const sx2 = x + Math.cos(angle)*dist;
    const sy2 = y + Math.sin(angle)*dist;
    circle(sx2,sy2,2,'#ffff00');
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PARTICLES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let parts=[];
function spawnParts(x,y,col,n,sp=5){for(let i=0;i<n;i++){const a=Math.random()*Math.PI*2,v=1+Math.random()*sp;parts.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v-2,life:30+Math.random()*22,col,sz:2+Math.random()*4});}}
function drawParts(){parts=parts.filter(p=>{p.x+=p.vx;p.y+=p.vy;p.vy+=.18;p.life--;ctx.globalAlpha=p.life/48;circle(p.x-camX,p.y,p.sz,p.col);ctx.globalAlpha=1;return p.life>0;});}

let flashT=0,flashC='#fff';
function flash(c,d=12){flashC=c;flashT=d;}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAME STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let state='idle',bet=.10,balance=10.00;
let multip=1.0,maxMult=1.0;
let coins_count=0,lives=3,waveNum=0,totalWaves=0;
let score=0; // Score du joueur
let firePowerActive=false,firePowerTimer=0,fireballs=[];
let unicorn=null,unicornTrail=[];
let showGambleScreen=false,gambleMultiplier=0;
let unicornSpawned=false; // Pour s'assurer qu'elle n'appara√Æt qu'une fois max
let bullSpawned=false; // Pour limiter √† 1 taureau maximum par partie
let spd=3.5, baseSpd=3.5;

// Fonctions pour sauvegarder/charger le solde
function saveBalance() {
  try {
    localStorage.setItem('raccoon_balance', balance.toString());
  } catch(e) {
    console.log('Could not save balance:', e);
  }
}

function loadBalance() {
  try {
    const saved = localStorage.getItem('raccoon_balance');
    if(saved) {
      const parsed = parseFloat(saved);
      if(!isNaN(parsed) && parsed >= 0) {
        balance = parsed;
      }
    }
  } catch(e) {
    console.log('Could not load balance:', e);
  }
}

function resetBalance() {
  balance = 10.00;
  saveBalance();
  updateBal();
}
let inputBlocked=false; // Bloquer les inputs apr√®s game over pendant 1.5s
let isFirstRun = true; // Track if this is the first game from title screen
let firstPortalSeen = false; // Track if first portal tutorial was shown
let hero={x:0,y:0,vy:0,onGround:true,frame:0,inv:0,invincible:false,koAnimating:false,koFrame:0,koStartTime:0,doubleJump:false};
let obstacles=[],enemies=[],projs=[],coins=[],platforms=[],bulls=[];
let portal=null,portalOpen=false;
let waveTimer=0,waveDur=0,wConf=null,eSp=0,pSp=0,tSp=0,bSp=0;
let fallPhase=0, fallVel=0, fallOffset=0, groundFallY=0;
let collapseTimer=0;

// Sky cycle system - changes every 3 waves
let skyPhase=0; // 0=day, 1=sunset, 2=night, 3=sunrise
let skyTransition=0; // 0-1 transition progress
let targetSkyPhase=0;
let isTransitioning=false;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// WAVE CONFIG ‚Äî difficulty scales with maxMult
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// multiplier targets per wave, based on maxMult
// If maxMult=1.1: many small portals
// If maxMult=5.0: fewer portals, each a big jump, heavy difficulty
function buildWaveMultipliers(maxM){
  // Cas sp√©cial pour x1.05 ou moins : seulement 2 portails
  if(maxM <= 1.05){
    const n = 2;
    const targets = [];
    
    // Premier portail : 0.50 √† 0.85
    const first = 0.50 + Math.random() * 0.35;
    targets.push(parseFloat(first.toFixed(2)));
    
    // Dernier portail = maxM
    targets.push(maxM);
    
    return {targets, n};
  }
  
  // Cas pour x1.06 √† x1.50 : 3-5 portails avec pattern vari√©
  if(maxM <= 1.50){
    const n = Math.floor(Math.random() * 3) + 3; // 3-5 portails
    const targets = [];
    const MIN_GAP = 0.10; // √âcart minimum entre 2 portails
    
    for(let i = 0; i < n - 1; i++){ // n-1 car on ajoute maxM s√©par√©ment
      let mult;
      
      if(i === 0){
        // Premier portail : x0.50 √† x1.00 avec variation
        mult = 0.50 + Math.random() * 0.50; // Plage compl√®te de 0.50 √† 1.00
        mult = parseFloat(mult.toFixed(2));
      } else {
        // Portails interm√©diaires : √©cart variable au-dessus du minimum
        const previousMult = targets[targets.length - 1];
        const remainingPortals = (n - 1) - i; // Portails restants avant maxM
        const remainingSpace = maxM - previousMult - MIN_GAP; // Espace jusqu'√† maxM
        
        // Assurer un √©cart minimum
        const minValue = previousMult + MIN_GAP;
        
        // Calculer l'√©cart maximal possible (laisser de la place pour les portails suivants)
        const maxPossibleGap = remainingSpace - (remainingPortals * MIN_GAP);
        
        // √âcart variable : MIN_GAP √† MIN_GAP + 0.30 (ou moins si pas assez d'espace)
        const extraGap = Math.random() * Math.min(0.30, maxPossibleGap);
        mult = previousMult + MIN_GAP + extraGap;
        
        mult = parseFloat(mult.toFixed(2));
        
        // S'assurer que mult reste dans les limites
        mult = Math.max(minValue, Math.min(maxM - (MIN_GAP * (remainingPortals + 1)), mult));
      }
      
      // V√©rifier unicit√© et √©cart minimum
      let attempts = 0;
      while(attempts < 30){
        let valid = true;
        
        // V√©rifier l'unicit√©
        if(targets.includes(mult)){
          valid = false;
        }
        
        // V√©rifier l'√©cart minimum avec tous les portails pr√©c√©dents
        for(let j = 0; j < targets.length; j++){
          if(Math.abs(mult - targets[j]) < MIN_GAP){
            valid = false;
            break;
          }
        }
        
        if(valid) break;
        
        // Ajuster si non valide
        mult += 0.03;
        mult = parseFloat(mult.toFixed(2));
        if(mult >= maxM - MIN_GAP) mult = targets[targets.length - 1] + MIN_GAP + Math.random() * 0.05;
        attempts++;
      }
      
      targets.push(mult);
    }
    
    // Trier les portails interm√©diaires par ordre croissant
    targets.sort((a, b) => a - b);
    
    // Ajouter maxM comme dernier portail (toujours en dernier)
    targets.push(maxM);
    
    return {targets, n};
  }
  
  // Pour maxMult > 1.50
  let minWaves, maxWaves;
  
  if(maxM <= 2.0){
    minWaves = 3;
    maxWaves = 6;
  } else if(maxM <= 5.0){
    minWaves = 2;
    maxWaves = 5;
  } else {
    minWaves = 2;
    maxWaves = 4;
  }
  
  const n = Math.floor(Math.random() * (maxWaves - minWaves + 1)) + minWaves;
  const targets = [];
  const MIN_GAP = 0.10; // √âcart minimum entre 2 portails
  
  for(let i = 0; i < n - 1; i++){ // n-1 car on ajoute maxM s√©par√©ment
    let mult;
    
    if(i === 0){
      // Premier portail : 0.95 √† 1.10 avec variation compl√®te de la plage
      mult = 0.95 + Math.random() * 0.15;
      mult = parseFloat(mult.toFixed(2));
    } else {
      // Portails interm√©diaires : √©cart variable
      const previousMult = targets[targets.length - 1];
      const remainingPortals = (n - 1) - i; // Portails restants avant maxM
      const remainingSpace = maxM - previousMult - MIN_GAP;
      
      // Assurer un √©cart minimum
      const minValue = previousMult + MIN_GAP;
      
      // Calculer l'√©cart maximal possible
      const maxPossibleGap = remainingSpace - (remainingPortals * MIN_GAP);
      
      // √âcart variable : MIN_GAP √† MIN_GAP + 0.50 (ou moins si pas assez d'espace)
      const extraGap = Math.random() * Math.min(0.50, maxPossibleGap);
      mult = previousMult + MIN_GAP + extraGap;
      
      mult = parseFloat(mult.toFixed(2));
      
      // S'assurer que mult reste dans les limites
      mult = Math.max(minValue, Math.min(maxM - (MIN_GAP * (remainingPortals + 1)), mult));
    }
    
    // V√©rifier unicit√© et √©cart minimum
    let attempts = 0;
    while(attempts < 30){
      let valid = true;
      
      // V√©rifier l'unicit√©
      if(targets.includes(mult)){
        valid = false;
      }
      
      // V√©rifier l'√©cart minimum avec tous les portails pr√©c√©dents
      for(let j = 0; j < targets.length; j++){
        if(Math.abs(mult - targets[j]) < MIN_GAP){
          valid = false;
          break;
        }
      }
      
      if(valid) break;
      
      // Ajuster si non valide
      mult += 0.05;
      mult = parseFloat(mult.toFixed(2));
      if(mult >= maxM - MIN_GAP) mult = targets[targets.length - 1] + MIN_GAP + Math.random() * 0.10;
      attempts++;
    }
    
    targets.push(mult);
  }
  
  // Trier les portails interm√©diaires par ordre croissant
  targets.sort((a, b) => a - b);
  
  // Ajouter maxM comme dernier portail (toujours en dernier)
  targets.push(maxM);
  
  return {targets, n};
}
// Difficulty for each wave (0=first, total=last)
// Scale: obsRate, bearCount, projCount, speed boost, wave duration
function waveDifficulty(wIdx,totalW,maxM){
  // Cas sp√©cial pour x1.00 : partie tr√®s difficile et courte
  if(maxM === 1.0){
    return {
      dur: 240,           // Dur√©e courte
      obsRate: 0.15,      // Beaucoup d'obstacles
      bearN: 6,           // 6 ours (beaucoup!)
      projN: 4,           // 4 projectiles
      coinN: 3,           // Quelques pi√®ces quand m√™me
      spdB: 0.8,          // Vitesse augment√©e
      pool: ['rock','tallrock','barrel','spike','fence','tombstone'], // Tous les obstacles
      platN: 2,           // Peu de plateformes
      bullChance: 0.0003  // Tr√®s peu de chances d'avoir un bull
    };
  }
  
  const progress=(wIdx+1)/totalW; // 0..1
  const diffMult=Math.log2(maxM+1); // scales 0 for x1 up to ~2.6 for x5
  // Duration: shorter for high mult
  const dur=Math.max(180,Math.floor(480-progress*160-diffMult*40));
  // obstacle rate: more obstacles for high mult and late game
  const obsRate=Math.min(.12, .012 + progress*.04 + diffMult*.018);
  // bear count
  const bearN=Math.floor(.5+progress*2.5*diffMult);
  // projectile count
  const projN=Math.floor(progress*2*diffMult);
  // coin count
  const coinN=Math.max(2,Math.floor(4-progress*1.5));
  // speed boost
  const spdB=progress*.6*diffMult+diffMult*.15;
  // obstacle pool
  const OBS_SETS=[['rock'],['rock','barrel'],['rock','barrel','spike'],['rock','tallrock','barrel','fence'],['rock','tallrock','barrel','spike','fence'],['rock','tallrock','barrel','spike','fence','tombstone']];
  const poolIdx=Math.min(OBS_SETS.length-1,Math.floor(progress*(OBS_SETS.length-1)));
  const pool=OBS_SETS[poolIdx];
  // platforms
  const platN=Math.min(4,Math.floor(progress*3.5+.5));
  // bull chance
  const bullChance=.0006+diffMult*.0002;
  return {dur,obsRate,bearN,projN,coinN,spdB,pool,platN,bullChance};
}

let waveMultipliers=[];
let originalWaveMultipliers=[]; // Sauvegarde des multiplicateurs originaux avant gamble
let SOL_PRICE = 200; // Prix du SOL en $ (sera mis √† jour en temps r√©el)

// Variables pour l'effet de warping lors du cash out
let warpEffect = false;
let warpProgress = 0;
let warpMaxDuration = 30; // frames (0.5 secondes √† 60fps)

// R√©cup√©rer le prix du SOL en temps r√©el via l'API CoinGecko
async function updateSOLPrice() {
  try {
    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
    const data = await response.json();
    if (data.solana && data.solana.usd) {
      SOL_PRICE = data.solana.usd;
      console.log('üí∞ SOL Price updated: $' + SOL_PRICE.toFixed(2));
      updateBal(); // Mettre √† jour l'affichage du balance
      if (typeof updateBetUSD === 'function') updateBetUSD(); // Mettre √† jour le bet USD
    }
  } catch (error) {
    console.warn('Failed to fetch SOL price, using default:', error);
  }
}

// Mettre √† jour le prix au chargement et toutes les 60 secondes
updateSOLPrice();
setInterval(updateSOLPrice, 60000);

// Fonction helper pour afficher SOL avec √©quivalent $
function formatSOL(amount, showProfit = false) {
  const usd = (amount * SOL_PRICE).toFixed(2);
  const sign = showProfit && amount > 0 ? '+' : '';
  return `${sign}${amount.toFixed(2)} SOL <span style="color:#888;font-size:0.85em">($${usd})</span>`;
}
let enemyType='bear'; // 'bear' or 'knight'

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HONEYMOON RTP SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function getPlayerIP(){
  // Pour l'instant on utilise un fingerprint basique du navigateur
  // En production, ce sera remplac√© par le wallet address
  const nav = navigator;
  const screen = window.screen;
  const fingerprint = [
    nav.userAgent,
    nav.language,
    screen.colorDepth,
    screen.width + 'x' + screen.height,
    new Date().getTimezoneOffset()
  ].join('|');
  
  // Hash simple du fingerprint
  let hash = 0;
  for(let i = 0; i < fingerprint.length; i++) {
    const char = fingerprint.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return 'fp_' + Math.abs(hash);
}

function getGamesPlayed(){
  const playerId = getPlayerIP();
  const key = 'raccoon_games_' + playerId;
  const saved = localStorage.getItem(key);
  return saved ? parseInt(saved) : 0;
}

function incrementGamesPlayed(){
  const playerId = getPlayerIP();
  const key = 'raccoon_games_' + playerId;
  const current = getGamesPlayed();
  localStorage.setItem(key, (current + 1).toString());
}

function isHoneymoonPhase(){
  return getGamesPlayed() < 3;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RTP ROLL ‚Äî 97% RTP (ou 102% pour honeymoon)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function rollMaxMult(){
  // V√©rifier si on est en phase honeymoon
  const honeymoon = isHoneymoonPhase();
  
  if(honeymoon){
    // HONEYMOON RTP (~102%) - Scores plus avantageux
    // Plus de gros multiplicateurs, moins de crashs
    const vals=[1.0, 1.05, 1.2, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 7.5, 10.0, 15.0];
    const wts= [3,   4,    6,   8,   10,  10,  9,   8,   7,   5,   4,   2];
    // Beaucoup moins de 1.0 et 1.05 (crashs), plus de multiplicateurs moyens/√©lev√©s
    let tot=wts.reduce((a,b)=>a+b),rr=Math.random()*tot;
    for(let i=0;i<vals.length;i++){rr-=wts[i];if(rr<=0)return vals[i];}
    return 2.0;
  } else {
    // RTP NORMAL (~97%)
    // Weighted distribution targeting 97% RTP
    // Many low values (crash early) balanced by rare big wins
    const vals=[1.0, 1.05, 1.1, 1.2, 1.35, 1.5, 1.8, 2.0, 2.5, 3.0, 4.0, 5.0, 7.5, 10.0];
    const wts= [8,   10,   12,  11,  10,   9,   8,   7,   6,   5,   5,   4,   3,   2];
    // vals 1.0 and 1.05 = losing games (crash before 1st portal or barely)
    let tot=wts.reduce((a,b)=>a+b),rr=Math.random()*tot;
    for(let i=0;i<vals.length;i++){rr-=wts[i];if(rr<=0)return vals[i];}
    return 1.2;
  }
}

function startGame(){
  ia();
  
  // D√©marrer la musique de fond et s'assurer que les autres musiques sont arr√™t√©es
  const bgMusic = document.getElementById('bgmusic');
  const invMusic = document.getElementById('invmusic');
  const fireMusic = document.getElementById('firemusic');
  invMusic.pause(); // Arr√™ter la musique d'invincibilit√© si elle jouait
  invMusic.currentTime = 0; // R√©initialiser
  fireMusic.pause(); // Arr√™ter la musique de feu si elle jouait
  fireMusic.currentTime = 0; // R√©initialiser
  bgMusic.currentTime = 0; // Red√©marrer depuis le d√©but
  bgMusic.play().catch(e => console.log('Music autoplay prevented:', e));
  
  maxMult=rollMaxMult();
  
  // Debug: afficher si on est en honeymoon
  const gamesPlayed = getGamesPlayed();
  const honeymoon = isHoneymoonPhase();
  console.log(`ü¶ù Game #${gamesPlayed + 1} | Honeymoon: ${honeymoon ? '‚ú® YES' : 'NO'} | MaxMult: √ó${maxMult}`);
  
  bet=parseFloat(document.getElementById('bip').value)||.10;
  if(bet>balance){bet=balance;}
  balance-=bet;
  state='playing';multip=1.0;coins_count=0;lives=1;waveNum=0;score=0;
  updateScore(); // Mettre √† jour l'affichage du score √† 0
  F=0;camX=0;camFrozen=false;
  inputBlocked=false; // D√©bloquer les inputs pour la nouvelle partie
  firstPortalSeen=false; // Reset tutorial flag for new game
  obstacles=[];enemies=[];projs=[];coins=[];platforms=[];parts=[];bulls=[];spikeWall=null;spikeWallPending=false;
  portal=null;portalOpen=false;
  fallPhase=0;fallVel=0;fallOffset=0;groundFallY=0;collapseTimer=0;
  hero={x:220,y:GY,vy:0,onGround:true,frame:0,inv:0,invincible:false,koAnimating:false,koFrame:0,koStartTime:0,doubleJump:false};
  
  // Initialiser le ciel avec une phase al√©atoire
  skyPhase = Math.floor(Math.random() * 4); // 0=day, 1=sunset, 2=night, 3=sunrise
  skyTransition = 0;
  isTransitioning = false;
  
  // Initialiser le type d'ennemi (commence toujours avec des ours)
  enemyType = 'bear';
  
  // Initialiser firepower
  firePowerActive = false;
  firePowerTimer = 0;
  fireballs = [];
  
  // Initialiser licorne
  unicorn = null;
  unicornTrail = [];
  showGambleScreen = false;
  unicornSpawned = false; // Reset pour nouvelle partie
  bullSpawned = false; // Reset pour nouvelle partie - max 1 taureau
  
  const {targets,n}=buildWaveMultipliers(maxMult);
  waveMultipliers=targets;totalWaves=n;
  originalWaveMultipliers=[...targets]; // Sauvegarder les multiplicateurs originaux
  
  // DEBUG: afficher les multiplicateurs g√©n√©r√©s
  console.log('üéØ Multiplicateurs g√©n√©r√©s:', waveMultipliers.map(m => `√ó${m}`).join(', '));
  
  document.getElementById('ov').classList.add('hide');
  document.getElementById('palert').classList.add('on');
  document.getElementById('palertmsg').textContent='wait for next portal to cash out';
  document.getElementById('pwtxt').style.display='none';
  document.getElementById('palertsub').style.display='none';
  document.getElementById('invbanner').classList.remove('on');
  document.getElementById('crashbig').style.display='none';
  document.getElementById('gambleScreen').style.display='none';
  nextWave();updateHUD();updateBal();
}

function nextWave(){
  waveNum++;
  if(waveNum>totalWaves){
    // All waves cleared = we've passed maxMult, should not happen if cashout forced
    triggerCrash();return;
  }
  
  // Ajouter 300 points pour avoir pass√© le portail sans cash out (sauf au d√©marrage)
  if(waveNum > 1) {
    score += 300;
    updateScore();
  }
  
  wConf=waveDifficulty(waveNum-1,totalWaves,maxMult);
  waveDur=wConf.dur;waveTimer=0;eSp=0;pSp=0;tSp=0;bSp=0;
  spd=baseSpd+wConf.spdB;
  if(hero.invincible)spd*=1.5; // keep boost if still invincible
  portal=null;portalOpen=false;
  document.getElementById('palertmsg').textContent='wait for next portal to cash out';
  document.getElementById('pwtxt').style.display='none';
  document.getElementById('palertsub').style.display='none';
  
  // Sky transition every 3 waves
  if(waveNum % 3 === 0) {
    targetSkyPhase = (skyPhase + 1) % 4; // Cycle through 0,1,2,3
    isTransitioning = true;
    skyTransition = 0;
  }
  
  // Change enemy type every 3 waves
  if(waveNum % 3 === 0) {
    enemyType = enemyType === 'bear' ? 'knight' : 'bear';
  }
  
  // Platforms - syst√®me √† deux niveaux avec progression logique
  platforms=[];
  const platY1=GY-100; // Premier niveau (bas)
  const platY2=GY-220; // Deuxi√®me niveau (haut)
  const jumpDistance=180; // Distance horizontale r√©duite pour sauts atteignables
  
  // Cr√©er des paires de plateformes : bas -> haut -> bas -> haut...
  for(let i=0;i<wConf.platN;i++){
    const baseX = hero.x+W*.6+i*jumpDistance;
    const platW = 110+Math.random()*40;
    
    if(i % 2 === 0) {
      // Plateforme niveau bas
      platforms.push({
        x:baseX+Math.random()*30,
        y:platY1-Math.random()*15,
        w:platW,
        level:1
      });
    } else {
      // Plateforme niveau haut (√† distance de saut de la pr√©c√©dente)
      platforms.push({
        x:baseX+Math.random()*30,
        y:platY2-Math.random()*15,
        w:platW,
        level:2
      });
    }
  }
  
  // Ajouter quelques plateformes bonus au niveau haut avec des plateformes d'acc√®s
  if(wConf.platN > 3) {
    const bonusX = hero.x+W*1.2+wConf.platN*jumpDistance*.3;
    // D'abord une plateforme basse pour y acc√©der
    platforms.push({
      x:bonusX,
      y:platY1-Math.random()*15,
      w:100+Math.random()*30,
      level:1
    });
    // Puis une plateforme haute
    platforms.push({
      x:bonusX+140,
      y:platY2-Math.random()*15,
      w:100+Math.random()*30,
      level:2
    });
  }
}

function endWave(){
  sWave();
  
  // R√©cup√©rer le multiplicateur original de CE portail (celui qui vient de se terminer)
  const currentPortalMult = originalWaveMultipliers[waveNum-1] || maxMult;
  
  // Tous les portails sont maintenant en hauteur (n√©cessite double saut)
  const isHighPortal = true;
  const portalY = GY - 280; // Hauteur de double saut pour tous les portails
  
  // Si c'est le dernier portail (final)
  if(waveNum>=totalWaves){
    portal={x:hero.x+W*.7,y:portalY,t:0,life:300,final:true,mult:currentPortalMult,isHigh:isHighPortal};
    portalOpen=true;
    document.getElementById('palertmsg').textContent='‚¨Ü‚¨Ü DOUBLE JUMP INTO PORTAL TO CASH OUT';
    document.getElementById('pwtxt').style.display='block';
    document.getElementById('palertsub').style.display='block';
    const winAmount = bet * currentPortalMult;
    const usd = (winAmount * SOL_PRICE).toFixed(2);
    document.getElementById('pwtxt').innerHTML='√ó'+currentPortalMult.toFixed(2)+' ‚Üí '+winAmount.toFixed(2)+' SOL <span style="color:#888;font-size:0.85em">($'+usd+')</span>';
    sPortal();
    // Mettre √† jour le HUD avec le multiplicateur du portail actuel
    multip = currentPortalMult;
    const m=document.getElementById('hm');m.textContent='√ó'+currentPortalMult.toFixed(2);
    m.className='hv '+(currentPortalMult>=maxMult*.85?'red':hero.invincible?'inv':'gold');
    
    // Show tutorial on first portal of first game
    if(isFirstRun && !firstPortalSeen) {
      firstPortalSeen = true;
    }
  } else {
    // Portail normal - cr√©er le portail avec son multiplicateur
    portal={x:hero.x+W*.7,y:portalY,t:0,life:660,final:false,mult:currentPortalMult,isHigh:isHighPortal};
    portalOpen=true;
    document.getElementById('palertmsg').textContent='‚¨Ü‚¨Ü DOUBLE JUMP INTO PORTAL TO CASH OUT';
    document.getElementById('pwtxt').style.display='block';
    document.getElementById('palertsub').style.display='block';
    const profit = bet * currentPortalMult - bet;
    const usd = ((bet * currentPortalMult) * SOL_PRICE).toFixed(2);
    const profitSign = profit >= 0 ? '+' : '';
    document.getElementById('pwtxt').innerHTML=profitSign+profit.toFixed(2)+' SOL <span style="color:#888;font-size:0.85em">($'+usd+')</span>  (√ó'+currentPortalMult.toFixed(2)+')';
    sPortal();
    // Mettre √† jour multip pour le HUD
    multip = currentPortalMult;
    const m=document.getElementById('hm');m.textContent='√ó'+currentPortalMult.toFixed(2);
    m.className='hv '+(currentPortalMult>=maxMult*.85?'red':hero.invincible?'inv':'gold');
    
    // Show tutorial on first portal of first game
    if(isFirstRun && !firstPortalSeen) {
      firstPortalSeen = true;
    }
  }
}

function triggerCrash(){
  if(state!=='playing')return;
  state='crashing';
  
  // Hide tutorial
  document.getElementById('tutorialMsg').classList.remove('show');
  document.getElementById('tutorialArrow').classList.remove('show');
  
  // Bloquer les inputs pendant 1.5 secondes
  inputBlocked = true;
  setTimeout(() => { inputBlocked = false; }, 1500);
  
  // Arr√™ter toutes les musiques
  const bgMusic = document.getElementById('bgmusic');
  const invMusic = document.getElementById('invmusic');
  const fireMusic = document.getElementById('firemusic');
  bgMusic.pause();
  invMusic.pause();
  fireMusic.pause();
  
  camFrozen=true;frozenCamX=camX;
  sFall();fallPhase=1;
  document.getElementById('crashbig').style.display='block';
  
  // Afficher "you missed X..." si le multiplicateur max √©tait > 1.01
  const crashSubEl = document.getElementById('crashsub');
  if(maxMult > 1.01) {
    const missedAmount = (bet * maxMult).toFixed(2);
    const missedUSD = (missedAmount * SOL_PRICE).toFixed(2);
    crashSubEl.innerHTML = `You missed √ó${maxMult.toFixed(2)}<br>${missedAmount} SOL <span style="color:#ff8866;font-size:0.85em">($${missedUSD})</span><br><span style="color:#9945FF;font-size:1em;margin-top:12px;display:block;">SCORE: ${score.toLocaleString()}</span>`;
  } else {
    crashSubEl.innerHTML = `<span style="color:#9945FF;font-size:1.2em;">SCORE: ${score.toLocaleString()}</span>`;
  }
  
  document.getElementById('palert').classList.remove('on');
}

function cashOut(){
  if(state!=='playing')return;state='cashed';
  
  // Hide tutorial
  document.getElementById('tutorialMsg').classList.remove('show');
  document.getElementById('tutorialArrow').classList.remove('show');
  
  // Bloquer les inputs pendant 1.5 secondes
  inputBlocked = true;
  setTimeout(() => { inputBlocked = false; }, 1500);
  
  // Arr√™ter toutes les musiques
  const bgMusic = document.getElementById('bgmusic');
  const invMusic = document.getElementById('invmusic');
  const fireMusic = document.getElementById('firemusic');
  bgMusic.pause();
  invMusic.pause();
  fireMusic.pause();
  
  const actualMult = portal && portal.mult ? portal.mult : multip; // Utiliser le mult du portail
  const win=bet*actualMult;balance+=win;sCash();flash('#9945FF',30);
  document.getElementById('palert').classList.remove('on');
  document.getElementById('invbanner').classList.remove('on');
  
  // Incr√©menter le compteur de parties jou√©es
  incrementGamesPlayed();
  
  // Pr√©parer l'√©cran de victoire (invisible) AVANT le warp
  const victoryScreen = document.getElementById('victoryScreen');
  victoryScreen.style.display = 'flex';
  victoryScreen.style.opacity = '0';
  
  // Synchroniser le bet de victoire avec le bet actuel
  document.getElementById('bipVictory').value = bet.toFixed(2);
  updateBetVictoryUSD();
  
  // Mettre √† jour le solde affich√©
  const balanceUSD = (balance * SOL_PRICE).toFixed(2);
  document.getElementById('bspVictory').innerHTML = `${balance.toFixed(2)} <span style="color:#888;font-size:0.85em">($${balanceUSD})</span>`;
  
  // Mettre √† jour le montant
  const winUSD = (win * SOL_PRICE).toFixed(2);
  const profitUSD = ((win - bet) * SOL_PRICE).toFixed(2);
  const finalScore = Math.floor(score * actualMult); // Score multipli√© par le multiplicateur
  document.getElementById('victoryAmount').innerHTML = '√ó'+actualMult.toFixed(2)+' ‚Üí Won '+win.toFixed(2)+' SOL <span style="color:#888">($'+winUSD+')</span><br><span style="font-size:16px;color:#888;margin-top:10px;display:block;">profit: +'+(win-bet).toFixed(2)+' SOL ($'+profitUSD+')</span><br><span style="font-size:14px;color:#9945FF;margin-top:8px;display:block;">SCORE: '+finalScore.toLocaleString()+'</span>';
  
  // Modifier le message selon le multiplicateur
  const victoryMsg = document.getElementById('victoryMessage');
  if(actualMult <= 1.00) {
    victoryMsg.textContent = 'BETTER THAN NOTHING!';
    victoryMsg.style.color = '#888888';
    victoryMsg.style.textShadow = '0 0 10px rgba(136,136,136,.5)';
  } else {
    victoryMsg.textContent = 'CONGRATS BRO!';
    victoryMsg.style.color = '#FFD700';
    victoryMsg.style.textShadow = '0 0 20px rgba(255,215,0,.8)';
  }
  
  // D√©marrer l'animation
  victoryAnimFrame = 0;
  animateVictory();
  
  // Mettre √† jour le solde
  updateBal();
  
  // D√©clencher l'effet de warping (le canvas reste visible)
  warpEffect = true;
  warpProgress = 0;
}

function animateVictory() {
  const img = document.getElementById('victoryDance');
  if (!img) {
    console.log('Victory image element not found');
    return;
  }
  
  if (victoryFrames.length === 0) {
    console.log('Victory frames not loaded');
    return;
  }
  
  // Utiliser l'index de frame pour alterner entre les images
  const frameIndex = Math.floor(victoryAnimFrame) % victoryFrames.length;
  const currentFrame = victoryFrames[frameIndex];
  
  if (currentFrame && currentFrame.src) {
    img.src = currentFrame.src;
    console.log('Frame', frameIndex, 'loaded');
  } else {
    console.log('Frame not ready');
  }
  
  victoryAnimFrame += 0.2; // Vitesse d'animation
  setTimeout(animateVictory, 150); // ~6-7 FPS
}

function killHero(){
  if(state!=='playing' && state!=='dying')return;state='dead';sDeath();flash('#ff0000',26);
  
  // Bloquer les inputs pendant 1.5 secondes
  inputBlocked = true;
  setTimeout(() => { inputBlocked = false; }, 1500);
  
  // Arr√™ter toutes les musiques
  const bgMusic = document.getElementById('bgmusic');
  const invMusic = document.getElementById('invmusic');
  const fireMusic = document.getElementById('firemusic');
  bgMusic.pause();
  invMusic.pause();
  fireMusic.pause();
  
  spawnParts(hero.x,hero.y-40,'#ff2200',20,7);spawnParts(hero.x,hero.y-40,'#ff8800',14,5);
  document.getElementById('palert').classList.remove('on');
  document.getElementById('invbanner').classList.remove('on');
  
  // Incr√©menter le compteur de parties jou√©es
  incrementGamesPlayed();
  
  setTimeout(()=>{
    document.getElementById('ov').classList.remove('hide');
    
    // Construire le titre avec "you missed" si maxMult > 1.01
    let titleHTML = '<span style="font-size:48px;color:#ff4444;text-shadow:0 0 20px rgba(255,68,68,.8);">üíÄ DEFEATED!</span>';
    
    if(maxMult > 1.01) {
      const missedAmount = (bet * maxMult).toFixed(2);
      const missedUSD = (missedAmount * SOL_PRICE).toFixed(2);
      titleHTML += '<br><br><span style="color:#ff6644;font-size:18px;">You missed √ó'+maxMult.toFixed(2)+'<br>'+missedAmount+' SOL <span style="color:#ff8866;font-size:0.9em">($'+missedUSD+')</span><br><span style="color:#9945FF;font-size:14px;margin-top:8px;display:block;">SCORE: '+score.toLocaleString()+'</span></span>';
    } else {
      titleHTML += '<br><br><span style="color:#9945FF;font-size:14px;">SCORE: '+score.toLocaleString()+'</span>';
    }
    
    document.getElementById('otit').innerHTML = titleHTML;
    document.getElementById('ores').className='ores lose';
    document.getElementById('ores').innerHTML = '';
    document.getElementById('pbtn').textContent='‚Ü∫ TRY AGAIN';
    document.getElementById('homebtn').style.display='block';
    document.getElementById('osub').innerHTML='';
    updateBal();
  },900);
}

function hitHero(){
  if(hero.invincible||hero.inv>0)return;
  
  // Changer imm√©diatement l'√©tat pour bloquer le mouvement
  state='dying';
  
  lives=0;sHit();flash('#ff4444',10);
  
  // Arr√™ter toutes les musiques
  const bgMusic = document.getElementById('bgmusic');
  const invMusic = document.getElementById('invmusic');
  const fireMusic = document.getElementById('firemusic');
  bgMusic.pause();
  invMusic.pause();
  fireMusic.pause();
  
  // D√©clencher l'animation KO
  hero.koFrame = 0;
  hero.koAnimating = true;
  hero.koStartTime = Date.now();
  
  spawnParts(hero.x,hero.y-40,'#ff2200',8);updateHUD();
  
  // Tuer le h√©ros apr√®s l'animation (4 frames * 150ms = 600ms)
  setTimeout(() => {
    hero.koAnimating = false;
    killHero();
  }, 600);
}

function spawnObs(){
  const t=wConf.pool[Math.floor(Math.random()*wConf.pool.length)];
  obstacles.push({x:hero.x+W+50+Math.random()*80,type:t});
  if(Math.random()<.3&&waveNum>=2)obstacles.push({x:hero.x+W+240+Math.random()*70,type:wConf.pool[Math.floor(Math.random()*wConf.pool.length)]});
}
function spawnBear(){
  // Calculer une meilleure r√©partition bas√©e sur le nombre d'ours d√©j√† g√©n√©r√©s
  const bearCount = enemies.filter(e => e.type === 'bear').length;
  const totalBears = wConf ? wConf.bearN : 1;
  
  // R√©partir les ours sur une zone plus large (600px au lieu de 180px)
  const spreadZone = 600;
  const baseOffset = W + 50; // Distance minimale devant le h√©ros
  
  // Position de base calcul√©e selon l'index de l'ours
  const positionRatio = totalBears > 1 ? bearCount / (totalBears - 1) : 0.5;
  const calculatedOffset = positionRatio * spreadZone;
  
  // Petite variation al√©atoire pour √©viter l'alignement parfait (¬±30px au lieu de ¬±90px)
  const randomVariation = (Math.random() - 0.5) * 60;
  
  enemies.push({
    x: hero.x + baseOffset + calculatedOffset + randomVariation,
    type: 'bear',
    frame: 0
  });
}
function spawnProj(){projs.push({x:hero.x+W+Math.random()*100,y:GY-(18+Math.random()*95),spd:5.5+Math.random()*3.5});}
function spawnCoin(){
  // 60% de chance de placer la pi√®ce sur une plateforme haute
  if(Math.random() < 0.6 && platforms.length > 0) {
    // Trouver les plateformes de niveau 2
    const highPlats = platforms.filter(p => p.level === 2);
    
    if(highPlats.length > 0) {
      // Choisir une plateforme haute al√©atoire
      const plat = highPlats[Math.floor(Math.random() * highPlats.length)];
      // Placer la pi√®ce sur ou juste au-dessus de la plateforme
      const coinX = plat.x + plat.w * (0.2 + Math.random() * 0.6);
      const coinY = plat.y - (20 + Math.random() * 40);
      coins.push({x:coinX, y:coinY, t:0});
      return;
    }
  }
  
  // Sinon, spawn normal √† diff√©rentes hauteurs
  const levelChoice = Math.random();
  let coinY;
  
  if(levelChoice < 0.4) {
    coinY = GY-(45+Math.random()*50);
  } else if(levelChoice < 0.7) {
    coinY = GY-(120+Math.random()*50);
  } else {
    coinY = GY-(200+Math.random()*60);
  }
  
  coins.push({x:hero.x+W*.55+Math.random()*W*.45, y:coinY, t:0});
}
function spawnBull(){bulls.push({x:hero.x+W+Math.random()*120,t:0});}

function spawnUnicorn(){
  // Tr√®s rare - maximum 1 licorne par partie
  // Ne pas spawn apr√®s le dernier portail (inutile)
  if(!unicorn && !unicornSpawned && waveNum < totalWaves && Math.random() < 0.0001) { // 0.01% de chance par frame = tr√®s rare
    const heights = [GY-120, GY-160, GY-200, GY-240];
    unicorn = {
      x: hero.x + W + 100,
      y: heights[Math.floor(Math.random()*heights.length)],
      t: 0,
      targetY: GY-180, // Altitude cible initiale
      vy: 0 // Vitesse verticale
    };
    unicornTrail = [];
    unicornSpawned = true; // Marquer qu'elle a spawn - ne respawnera plus cette partie
  }
}

function resolveGamble(risk){
  if(!showGambleScreen) return;
  
  // Masquer l'√©cran de gamble
  document.getElementById('gambleScreen').style.display = 'none';
  showGambleScreen = false;
  
  const resultDiv = document.getElementById('gambleResult');
  
  if(risk) {
    // 49% de chances de gagner
    const won = Math.random() < 0.49;
    
    if(won) {
      const oldMult = gambleMultiplier;
      const newMult = gambleMultiplier * 2;
      
      // V√©rifier si le portail actuel est encore visible √† l'√©cran ET √† droite du joueur
      const portalOnScreenRight = portal && portal.life > 0 && portal.x > hero.x && (portal.x - camX) < W;
      
      if(portalOnScreenRight) {
        // Modifier le portail actuel qui est encore √† l'√©cran et atteignable
        portal.mult = parseFloat(newMult.toFixed(2));
        // Aussi mettre √† jour originalWaveMultipliers pour coh√©rence
        if(waveNum - 1 >= 0 && waveNum - 1 < originalWaveMultipliers.length) {
          originalWaveMultipliers[waveNum - 1] = parseFloat(newMult.toFixed(2));
        }
        
        // Mettre √† jour l'affichage de l'alerte du portail et le HUD
        const profit = bet * newMult - bet;
        const usd = ((bet * newMult) * SOL_PRICE).toFixed(2);
        const profitSign = profit >= 0 ? '+' : '';
        document.getElementById('pwtxt').innerHTML=profitSign+profit.toFixed(2)+' SOL <span style="color:#888;font-size:0.85em">($'+usd+')</span>  (√ó'+newMult.toFixed(2)+')';
        multip = newMult;
        const m=document.getElementById('hm');m.textContent='√ó'+newMult.toFixed(2);
        m.className='hv '+(newMult>=maxMult*.85?'red':hero.invincible?'inv':'gold');
        
        console.log(`ü¶Ñ Gamble WON: Portail actuel √† l'√©cran passe de √ó${oldMult.toFixed(2)} √† √ó${newMult.toFixed(2)}`);
      } else {
        // Modifier le prochain portail si l'actuel n'est plus atteignable ou hors √©cran
        if(waveNum < originalWaveMultipliers.length) {
          originalWaveMultipliers[waveNum] = parseFloat(newMult.toFixed(2));
          console.log(`ü¶Ñ Gamble WON: Prochain portail (${waveNum + 1}) passe de √ó${oldMult.toFixed(2)} √† √ó${newMult.toFixed(2)}`);
        }
      }
      
      sUnicornWin();
      flash('#44ff88',25);
      
      // Afficher popup de victoire
      resultDiv.className = 'gambleResult win show';
      resultDiv.innerHTML = `ü¶Ñ YOU WON! üéâ<br><span style="font-size:32px;font-weight:bold;text-shadow:0 0 20px rgba(68,255,136,1);">Next portal: √ó${oldMult.toFixed(2)} ‚Üí √ó${newMult.toFixed(2)}</span>`;
      
    } else {
      const oldMult = gambleMultiplier;
      const newMult = gambleMultiplier / 2;
      
      // V√©rifier si le portail actuel est encore visible √† l'√©cran ET √† droite du joueur
      const portalOnScreenRight = portal && portal.life > 0 && portal.x > hero.x && (portal.x - camX) < W;
      
      if(portalOnScreenRight) {
        // Modifier le portail actuel qui est encore √† l'√©cran et atteignable
        portal.mult = parseFloat(newMult.toFixed(2));
        // Aussi mettre √† jour originalWaveMultipliers pour coh√©rence
        if(waveNum - 1 >= 0 && waveNum - 1 < originalWaveMultipliers.length) {
          originalWaveMultipliers[waveNum - 1] = parseFloat(newMult.toFixed(2));
        }
        
        // Mettre √† jour l'affichage de l'alerte du portail et le HUD
        const profit = bet * newMult - bet;
        const usd = ((bet * newMult) * SOL_PRICE).toFixed(2);
        const profitSign = profit >= 0 ? '+' : '';
        document.getElementById('pwtxt').innerHTML=profitSign+profit.toFixed(2)+' SOL <span style="color:#888;font-size:0.85em">($'+usd+')</span>  (√ó'+newMult.toFixed(2)+')';
        multip = newMult;
        const m=document.getElementById('hm');m.textContent='√ó'+newMult.toFixed(2);
        m.className='hv '+(newMult>=maxMult*.85?'red':hero.invincible?'inv':'gold');
        
        console.log(`ü¶Ñ Gamble LOST: Portail actuel √† l'√©cran passe de √ó${oldMult.toFixed(2)} √† √ó${newMult.toFixed(2)}`);
      } else {
        // Modifier le prochain portail si l'actuel n'est plus atteignable ou hors √©cran
        if(waveNum < originalWaveMultipliers.length) {
          originalWaveMultipliers[waveNum] = parseFloat(newMult.toFixed(2));
          console.log(`ü¶Ñ Gamble LOST: Prochain portail (${waveNum + 1}) passe de √ó${oldMult.toFixed(2)} √† √ó${newMult.toFixed(2)}`);
        }
      }
      
      sUnicornLose();
      flash('#ff4444',25);
      
      // Afficher popup de d√©faite
      resultDiv.className = 'gambleResult lose show';
      resultDiv.innerHTML = `üíî YOU LOST!<br><span style="font-size:32px;font-weight:bold;text-shadow:0 0 20px rgba(255,68,68,1);">Next portal: √ó${oldMult.toFixed(2)} ‚Üí √ó${newMult.toFixed(2)}</span>`;
    }
    
    // Masquer le popup apr√®s 2.5 secondes
    setTimeout(() => {
      resultDiv.classList.remove('show');
    }, 2500);
    
  } else {
    // Si pas de risque, afficher qu'on garde le multiplicateur
    resultDiv.className = 'gambleResult show';
    resultDiv.style.background = 'rgba(60,60,100,.95)';
    resultDiv.style.border = '3px solid #88aaff';
    resultDiv.style.color = '#88aaff';
    resultDiv.style.boxShadow = '0 0 30px rgba(136,170,255,.8)';
    resultDiv.innerHTML = `ü¶Ñ PLAYED IT SAFE<br><span style="font-size:28px;font-weight:bold;">Next portal keeps √ó${gambleMultiplier.toFixed(2)}</span>`;
    
    setTimeout(() => {
      resultDiv.classList.remove('show');
    }, 2000);
  }
  
  // Reprendre le jeu apr√®s un court d√©lai
  setTimeout(() => {
    state = 'playing';
    
    // Donner 2 secondes d'invincibilit√© (120 frames √† 60 FPS)
    // Utiliser uniquement hero.inv pour le clignotement, sans hero.invincible (qui active le taureau)
    hero.inv = 120;
    hero.invincible = false; // Ne pas activer le mode taureau
    
    // Pas de boost de vitesse pour l'invincibilit√© post-gamble
    // La vitesse reste normale
    
    // NE PAS afficher la banni√®re d'invincibilit√©
    document.getElementById('invbanner').classList.remove('on');
    updateHUD();
  }, 100);
}

let spikeWall=null;

function drawSpikeWall(sx,t){
  // Wall base
  const ww=48, wh=300;
  // Dark stone wall
  ctx.save();
  const grad=ctx.createLinearGradient(sx-ww/2,GY-wh,sx+ww/2,GY);
  grad.addColorStop(0,'#1a0a0a');grad.addColorStop(.5,'#2d1010');grad.addColorStop(1,'#1a0a0a');
  ctx.fillStyle=grad;
  ctx.fillRect(sx-ww/2,GY-wh,ww,wh);
  // Brick lines
  ctx.strokeStyle='rgba(0,0,0,.5)';ctx.lineWidth=1.5;
  for(let row=0;row<15;row++){
    const ry=GY-wh+row*20;
    ctx.beginPath();ctx.moveTo(sx-ww/2,ry);ctx.lineTo(sx+ww/2,ry);ctx.stroke();
    const offset=(row%2)*12;
    ctx.beginPath();ctx.moveTo(sx-ww/2+offset,ry);ctx.lineTo(sx-ww/2+offset,ry+20);ctx.stroke();
    ctx.beginPath();ctx.moveTo(sx-ww/2+offset+24,ry);ctx.lineTo(sx-ww/2+offset+24,ry+20);ctx.stroke();
  }
  // Red glow on wall
  ctx.fillStyle='rgba(255,30,0,'+(.15+.08*Math.sin(t*.15))+')';
  ctx.fillRect(sx-ww/2,GY-wh,ww,wh);
  // Spikes on top (pointing left toward hero)
  const spikeCount=7;
  const spikeLen=44;
  const spikeSpacing=wh/spikeCount;
  for(let i=0;i<spikeCount;i++){
    const sy=GY-wh+i*spikeSpacing+spikeSpacing/2;
    const pulse=Math.sin(t*.1+i*.9)*.04;
    ctx.save();
    ctx.translate(sx-ww/2, sy);
    // spike triangle pointing left
    ctx.beginPath();
    ctx.moveTo(-spikeLen*(1+pulse),0);
    ctx.lineTo(0,-9);
    ctx.lineTo(0,9);
    ctx.closePath();
    const sg=ctx.createLinearGradient(-spikeLen,0,0,0);
    sg.addColorStop(0,'#ff2200');sg.addColorStop(.5,'#cc1100');sg.addColorStop(1,'#881100');
    ctx.fillStyle=sg;ctx.fill();
    // shine on spike
    ctx.beginPath();ctx.moveTo(-spikeLen*.9,0);ctx.lineTo(-spikeLen*.4,-4);ctx.lineTo(-spikeLen*.1,-2);ctx.closePath();
    ctx.fillStyle='rgba(255,180,100,.35)';ctx.fill();
    ctx.restore();
  }
  // Dripping blood effect
  for(let i=0;i<4;i++){
    const dx=sx-ww/2+6+i*11;
    const dlen=10+8*Math.abs(Math.sin(t*.05+i*1.3));
    ctx.fillStyle='#cc0000';
    ctx.beginPath();ctx.ellipse(dx,GY-wh+dlen,2.5,dlen/2,0,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.arc(dx,GY-wh+dlen*1.7,3,0,Math.PI*2);ctx.fill();
  }
  ctx.restore();
}

function ovlp(ax,ay,aw,ah,bx,by,bw,bh){return ax<bx+bw&&ax+aw>bx&&ay<by+bh&&ay+ah>by;}

let lastJumpTime = 0;
function doJump(){
  if(state==='playing'){
    // Debounce pour √©viter les doubles appels (important sur mobile)
    const now = Date.now();
    if(now - lastJumpTime < 100) return; // Ignorer si moins de 100ms depuis le dernier saut
    lastJumpTime = now;
    
    // Hauteur de saut identique sur mobile et desktop maintenant
    const jumpPower = -16; // Saut normal
    const doubleJumpPower = -11; // Double saut normal
    
    // Premier saut (au sol)
    if(hero.onGround){
      hero.vy=jumpPower;
      hero.onGround=false;
      hero.doubleJump=false; // R√©initialiser le double saut
      sJump();
      spawnParts(hero.x,hero.y,'#9ab0ff',4,3);
    }
    // Double saut (en l'air, pas encore utilis√©)
    else if(!hero.doubleJump){
      hero.vy=doubleJumpPower;
      hero.doubleJump=true;
      sJump();
      spawnParts(hero.x,hero.y,'#ffcc00',6,3); // Particules dor√©es pour le double saut
    }
  }
}
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='ArrowUp'){
    e.preventDefault();
    
    // Bloquer les inputs si le d√©lai n'est pas √©coul√©
    if(inputBlocked) return;
    
    const ov=document.getElementById('ov');
    const victoryScreen=document.getElementById('victoryScreen');
    
    // Si l'√©cran de victoire est affich√©, d√©marrer une nouvelle partie
    if(victoryScreen && victoryScreen.style.display==='flex'){
      startGameFromVictory();
    }
    // Sinon comportement normal
    else if(!ov.classList.contains('hide')){
      startGame();
    }
    else{
      doJump();
    }
  }
});
cv.addEventListener('pointerdown',e=>{e.preventDefault();doJump();},{passive:false});

function updateHUD(){
  const m=document.getElementById('hm');
  
  // Si aucun portail visible, afficher "..."
  if(!portalOpen || !portal || portal.life <= 0){
    m.textContent='...';
    m.className='hv gold'; // Couleur neutre
  } else {
    m.textContent='√ó'+multip.toFixed(2);
    m.className='hv '+(multip>=maxMult*.85?'red':hero.invincible?'inv':'gold');
  }
  
  document.getElementById('goldcount').textContent='üü° '+coins_count;
  document.getElementById('goldgauge').style.width=(coins_count*10)+'%';
  const ld=document.getElementById('livdiv');ld.innerHTML='';
  
}
function updateBal(){
  const usd = (balance * SOL_PRICE).toFixed(2);
  document.getElementById('bsp').innerHTML = `${balance.toFixed(2)} <span style="color:#888;font-size:0.85em">($${usd})</span>`;
  saveBalance(); // Sauvegarder le solde
}
function adjBet(d){
  let v=parseFloat(document.getElementById('bip').value)||.1;
  v=Math.round(Math.max(.01,Math.min(0.5,v+d))*100)/100;
  document.getElementById('bip').value=v.toFixed(2);
  // Mettre √† jour l'affichage USD
  const usdValue = (v * SOL_PRICE).toFixed(2);
  document.getElementById('betusd').textContent = `($${parseFloat(usdValue).toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:2})})`;
}

function updateScore(){
  document.getElementById('scoreValue').textContent = score.toLocaleString();
}

// Fonctions pour l'√©cran de victoire
function adjustBetVictory(d){
  let v=parseFloat(document.getElementById('bipVictory').value)||.1;
  v=Math.round(Math.max(.01,Math.min(0.5,v+d))*100)/100;
  document.getElementById('bipVictory').value=v.toFixed(2);
  // Mettre √† jour l'affichage USD
  const usdValue = (v * SOL_PRICE).toFixed(2);
  document.getElementById('betVictoryUsd').textContent = `($${parseFloat(usdValue).toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:2})})`;
}

function updateBetVictoryUSD() {
  const betValue = parseFloat(document.getElementById('bipVictory').value) || 0.10;
  const usdValue = (betValue * SOL_PRICE).toFixed(2);
  document.getElementById('betVictoryUsd').textContent = `($${parseFloat(usdValue).toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:2})})`;
}

function startGameFromVictory() {
  // R√©cup√©rer le bet depuis l'input de victoire
  bet = parseFloat(document.getElementById('bipVictory').value) || 0.10;
  
  // V√©rifier que le joueur a assez d'argent
  if(bet > balance) {
    bet = balance;
    document.getElementById('bipVictory').value = bet.toFixed(2);
  }
  
  // Mark that this is not a first run from title screen
  isFirstRun = false;
  
  // Cacher l'√©cran de victoire
  document.getElementById('victoryScreen').style.display = 'none';
  document.getElementById('victoryScreen').style.opacity = '0';
  
  // D√©marrer la partie
  startGame();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function loop(){
  ctx.clearRect(0,0,W,H);

  // CRASH FALL PHASE
  if(state==='crashing'){
    F++;
    collapseTimer++;
    const camEffX=frozenCamX;
    // Draw background (frozen)
    drawSky(collapseTimer>60);
    if(collapseTimer<=60){drawStars();drawMoon();drawSun();drawClouds();drawMtnFar();drawMtnNear();drawBGTrees();drawFGTrees();drawTorches();}
    if(fallPhase>=1){
      groundFallY+=collapseTimer*.15;
      fallOffset=groundFallY;
    }
    drawGround(collapseTimer>60,fallOffset);
    // Spike wall during crash ‚Äî reste visible √† sa position
    if(spikeWall){
      spikeWall.t++;
      drawSpikeWall(spikeWall.x-frozenCamX, spikeWall.t);
    }
    // Hero falls straight down at impact point
    if(fallPhase>=1){
      hero.vy+=1.5; hero.y+=hero.vy;
    }
    drawRaccoon(hero.x-camEffX,hero.y,hero.frame,false,true,hero.vy);
    drawParts();
    // After 2.5s show result
    if(collapseTimer>150){
      if(state==='crashing'){
        state='crashed';
        
        document.getElementById('crashbig').style.display='none';
        document.getElementById('ov').classList.remove('hide');
        
        // Construire le titre avec "you missed" si maxMult > 1.01
        let titleHTML = '<span style="color:#ff4444;text-shadow:0 0 20px rgba(255,68,68,.8);">A greedy raccoon is a dead raccoon...</span>';
        
        if(maxMult > 1.01) {
          const missedAmount = (bet * maxMult).toFixed(2);
          const missedUSD = (missedAmount * SOL_PRICE).toFixed(2);
          titleHTML += '<br><br><span style="color:#ff6644;font-size:18px;">You missed √ó'+maxMult.toFixed(2)+'<br>'+missedAmount+' SOL <span style="color:#ff8866;font-size:0.9em">($'+missedUSD+')</span></span>';
        }
        
        document.getElementById('otit').innerHTML = titleHTML;
        document.getElementById('ores').className='ores lose';
        document.getElementById('ores').innerHTML = '';
        document.getElementById('pbtn').textContent='‚Ü∫ TRY AGAIN';
        document.getElementById('homebtn').style.display='block';
        document.getElementById('osub').innerHTML='';
        updateBal();
      }
    }
    if(flashT>0){ctx.globalAlpha=flashT/28*.28;ctx.fillStyle=flashC;ctx.fillRect(0,0,W,H);ctx.globalAlpha=1;flashT--;}
    requestAnimationFrame(loop);return;
  }

  // BG
  drawSky(false);drawStars();drawMoon();drawSun();drawClouds();drawMtnFar();drawMtnNear();drawBGTrees();drawFGTrees();drawTorches();drawGround(false,0);

  if(state==='paused'){
    // Afficher le jeu fig√© pendant le gamble
    drawRaccoon(hero.x-camX,hero.y,0,false,false,0);
    if(flashT>0){ctx.globalAlpha=flashT/28*.28;ctx.fillStyle=flashC;ctx.fillRect(0,0,W,H);ctx.globalAlpha=1;flashT--;}
    requestAnimationFrame(loop);
    return;
  }

  if(state==='dying'){
    // Animation de mort - afficher le jeu mais sans mouvement
    F++;
    // Continuer √† afficher les obstacles, ennemis, etc. mais sans les faire bouger
    obstacles.forEach(o=>drawObs(o));
    enemies.forEach(e=>{
      const sx=e.x-camX;
      if(e.type==='bear')drawBear(sx,GY,e.t);
      else if(e.type==='knight')drawKnight(sx,GY,e.t);
    });
    coins.forEach(c=>{c.t++;drawCoin(c.x-camX,c.y,c.t);});
    drawParts();
    
    // Afficher l'animation KO du h√©ros
    if (hero.koAnimating && koFrames.length > 0) {
      const elapsed = Date.now() - hero.koStartTime;
      const frameIndex = Math.min(Math.floor(elapsed / 150), koFrames.length - 1);
      const koImg = koFrames[frameIndex];
      if (koImg && koImg.complete) {
        const koWidth = 120;
        const koHeight = 120;
        ctx.drawImage(koImg, hero.x - camX - koWidth/2, hero.y - koHeight, koWidth, koHeight);
      }
    }
    
    if(flashT>0){ctx.globalAlpha=flashT/28*.28;ctx.fillStyle=flashC;ctx.fillRect(0,0,W,H);ctx.globalAlpha=1;flashT--;}
    requestAnimationFrame(loop);
    return;
  }

  if(state==='playing'){
    F++;waveTimer++;hero.frame++;
    
    // Sky transition progress
    if(isTransitioning) {
      skyTransition += 0.01; // Transition sur ~100 frames
      if(skyTransition >= 1) {
        skyTransition = 1;
        skyPhase = targetSkyPhase;
        isTransitioning = false;
      }
    }

    // HERO PHYSICS
    hero.x+=spd*(hero.invincible?1.5:1);
    hero.vy+=.7;hero.y+=hero.vy;
    if(hero.y>=GY){hero.y=GY;hero.vy=0;hero.onGround=true;hero.doubleJump=false;}
    if(hero.inv>0)hero.inv--;
    
    if(hero.invincible&&hero.inv<=0){
      hero.invincible=false;spd=baseSpd+wConf.spdB;updateHUD();
      
      // Reprendre la musique appropri√©e (fire si firepower actif, sinon normale)
      const bgMusic = document.getElementById('bgmusic');
      const invMusic = document.getElementById('invmusic');
      const fireMusic = document.getElementById('firemusic');
      
      invMusic.pause();
      
      if(firePowerActive) {
        fireMusic.play().catch(e => console.log('Fire music resume prevented:', e));
      } else {
        bgMusic.play().catch(e => console.log('Background music resume prevented:', e));
      }
      
      if(firePowerActive){document.getElementById('invbanner').textContent='üî• FIREPOWER! '+Math.ceil(firePowerTimer/60)+'s';document.getElementById('invbanner').classList.add('on');}
      else{document.getElementById('invbanner').classList.remove('on');}
    }

    // Platform
    platforms.forEach(pl=>{
      if(hero.vy>=0){const lx=hero.x-HERO_W/2,rx=hero.x+HERO_W/2;if(rx>pl.x&&lx<pl.x+pl.w){const prevY=hero.y-hero.vy;if(prevY<=pl.y&&hero.y>=pl.y-4){hero.y=pl.y;hero.vy=0;hero.onGround=true;hero.doubleJump=false;}}}
    });

    // CAMERA
    // Sur mobile, placer le h√©ros tr√®s √† gauche pour voir √©norm√©ment loin devant
    const isMobile = W <= 768;
    const heroScreenPos = isMobile ? 0.05 : 0.28; // 5% au lieu de 28% sur mobile (vue maximale)
    camX+=(hero.x-W*heroScreenPos-camX)*.09;

    // SPAWNING
    if(wConf&&waveTimer<waveDur){
      if(Math.random()<wConf.obsRate)spawnObs();
      if(eSp<wConf.bearN&&Math.random()<.02){spawnBear();eSp++;}
      if(pSp<wConf.projN&&Math.random()<.01){spawnProj();pSp++;}
      if(tSp<wConf.coinN&&Math.random()<.0088){spawnCoin();tSp++;} // +10% spawn rate
      if(!bullSpawned && Math.random()<0.0002&&(bulls.length===0||(hero.x-bulls[bulls.length-1].x)>W*1.5)){spawnBull(); bullSpawned=true;}
    }else if(wConf&&waveTimer>=waveDur&&!portalOpen&&!spikeWall&&!spikeWallPending){endWave();}

    const targetH=90,targetW=raccoonFrames[0].naturalWidth?raccoonFrames[0].naturalWidth/raccoonFrames[0].naturalHeight*targetH:52;
    const HERO_W2=targetW*.7, HERO_H2=targetH*.85;
    const hrx=hero.x-HERO_W2/2, hry=hero.y-HERO_H2;

    // PLATFORMS draw
    platforms.forEach(drawPlatform);

    // PORTAL
    if(portal){
      portal.t++;
      if(portalOpen&&portal.life>0){
        portal.life--;
        const psx=portal.x-camX;
        // Si le portail est off-screen √† gauche, changer le message imm√©diatement
        if(psx<-100){
          portalOpen=false;
          document.getElementById('palertmsg').textContent='wait for next portal to cash out';
          document.getElementById('pwtxt').style.display='none';
          document.getElementById('palertsub').style.display='none';
          updateHUD(); // Mettre √† jour le HUD pour afficher "..."
          if(portal.final){
            spikeWallPending=true;
          }else{
            nextWave();
          }
        }else{
          drawPortal(psx,portal.y,portal.t);
          
          // Show tutorial message on first portal
          if(firstPortalSeen && isFirstRun) {
            const tutMsg = document.getElementById('tutorialMsg');
            const tutArrow = document.getElementById('tutorialArrow');
            const msgX = psx + 120; // Position to the right of portal
            const msgY = portal.y - 220; // Above the portal
            tutMsg.style.left = msgX + 'px';
            tutMsg.style.top = msgY + 'px';
            tutMsg.classList.add('show');
            tutArrow.style.left = (psx - 20) + 'px';
            tutArrow.style.top = (portal.y - 150) + 'px';
            tutArrow.classList.add('show');
          } else {
            document.getElementById('tutorialMsg').classList.remove('show');
            document.getElementById('tutorialArrow').classList.remove('show');
          }
          
          // Collision avec le toit du portail (plateforme)
          const portalRoofY = portal.y - 130; // Position du toit
          const portalRoofX = portal.x - 54; // Bord gauche du toit
          const portalRoofW = 108; // Largeur du toit
          
          // V√©rifier si le h√©ros tombe sur le toit du portail
          if(hero.vy >= 0) {
            const heroLeft = hero.x - HERO_W/2;
            const heroRight = hero.x + HERO_W/2;
            if(heroRight > portalRoofX && heroLeft < portalRoofX + portalRoofW) {
              const prevY = hero.y - hero.vy;
              if(prevY <= portalRoofY && hero.y >= portalRoofY - 4) {
                hero.y = portalRoofY;
                hero.vy = 0;
                hero.onGround = true;
                hero.doubleJump = false;
              }
            }
          }
          
          if(ovlp(hrx-camX,hry,HERO_W2,HERO_H2, psx-32,portal.y-115, 64,115))cashOut();
        }
      }else if(portal.life<=0&&portalOpen){
        portalOpen=false;
        document.getElementById('palertmsg').textContent='wait for next portal to cash out';
        document.getElementById('pwtxt').style.display='none';
        document.getElementById('palertsub').style.display='none';
        updateHUD(); // Mettre √† jour le HUD pour afficher "..."
        // missed portal
        if(portal.final){
          spikeWallPending=true; // sera spawn√© au frame suivant depuis le bord droit
        }
        else{nextWave();}
      }
    }

    // OBSTACLES
    obstacles=obstacles.filter(obj=>{
      const sx=obj.x-camX;if(sx<-120)return false;
      drawObs(obj);
      let ow=52,oh=58;
      if(obj.type==='spike'){ow=78;oh=56;}
      if(obj.type==='fence'){ow=76;oh=42;}
      if(obj.type==='tallrock'){ow=34;oh=98;}
      if(obj.type==='barrel'){ow=38;oh=52;}
      if(obj.type==='tombstone'){ow=38;oh=76;}
      if(!hero.invincible&&ovlp(hrx-camX,hry,HERO_W2,HERO_H2, sx-ow/2,GY-oh,ow,oh))hitHero();
      return sx<W+80;
    });

    // ENEMIES (BEARS or KNIGHTS)
    enemies=enemies.filter(en=>{
      en.x-=spd*.4;en.frame++;
      const sx=en.x-camX;if(sx<-90)return false;
      if(enemyType === 'knight') {
        drawKnight(sx,GY,en.frame);
      } else {
        drawBear(sx,GY,en.frame);
      }
      // Hitbox adapt√©e au type d'ennemi
      const ew = enemyType === 'knight' ? 44 : 36;
      const eh = enemyType === 'knight' ? 85 : 72;
      if(!hero.invincible&&ovlp(hrx-camX,hry,HERO_W2,HERO_H2, sx-ew/2,GY-eh,ew,eh))hitHero();
      else if(hero.invincible&&ovlp(hrx-camX,hry,HERO_W2,HERO_H2, sx-ew/2,GY-eh,ew,eh)){
        enemyDeathEffect(en.x, en.y);
        return false;
      }
      return true;
    });

    // PROJECTILES
    projs=projs.filter(p=>{
      p.x-=p.spd;const sx=p.x-camX;if(sx<-50)return false;
      // Arrow
      ctx.save();ctx.translate(sx,p.y);
      ctx.fillStyle='#6a2808';ctx.beginPath();ctx.ellipse(-6,0,16,3.5,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#aaa';ctx.beginPath();ctx.ellipse(9,0,10,5,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#bbb';ctx.beginPath();ctx.ellipse(9,-1,8,3.5,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#cc2e00';ctx.beginPath();ctx.moveTo(-20,-3.5);ctx.lineTo(-24,0);ctx.lineTo(-20,3.5);ctx.closePath();ctx.fill();
      ctx.restore();
      if(!hero.invincible&&ovlp(hrx-camX,hry,HERO_W2,HERO_H2, sx-22,p.y-7,44,14)){hitHero();spawnParts(hero.x,p.y,'#ff4400',5,4);return false;}
      return true;
    });

    // GOLDEN BULLS
    bulls=bulls.filter(b=>{
      b.x-=spd*.22;b.t++;
      const sx=b.x-camX;if(sx<-100)return false;
      drawBull(sx,GY,b.t);
      const bw=64,bh=100;
      // Collect: hero overlaps bull ‚Üí INVINCIBLE 5s
      if(ovlp(hrx-camX,hry,HERO_W2,HERO_H2, sx-bw/2,GY-bh,bw,bh)){
        hero.invincible=true;hero.inv=480; // 8 seconds at 60fps
        
        // Transition vers la musique d'invincibilit√©
        const bgMusic = document.getElementById('bgmusic');
        const invMusic = document.getElementById('invmusic');
        const fireMusic = document.getElementById('firemusic');
        
        // Arr√™ter soit la musique de feu soit la musique normale
        if(firePowerActive) {
          fireMusic.pause();
        } else {
          bgMusic.pause();
        }
        
        invMusic.currentTime = 0;
        invMusic.play().catch(e => console.log('Invincible music play prevented:', e));
        
        score += 100; // 100 points pour le taureau dor√©
        updateScore();
        
        spawnParts(b.x,GY-50,'#FFD700',20,8);spawnParts(b.x,GY-50,'#ffffff',12,6);
        sBull();flash('#FFD700',18);
        document.getElementById('invbanner').textContent='‚ö° INVINCIBLE! √ó1.5 SPEED!';
        document.getElementById('invbanner').style.color = '#FFD700'; // R√©initialiser la couleur dor√©e
        document.getElementById('invbanner').classList.add('on');
        updateHUD();
        return false;
      }
      return true;
    });

    // COINS
    coins=coins.filter(c=>{
      c.t++;const sx=c.x-camX;if(sx<-30)return false;
      drawCoin(sx,c.y,c.t);
      if(ovlp(hrx-camX,hry,HERO_W2,HERO_H2, sx-13,c.y-13,26,26)){
        coins_count++;
        score += 30; // 30 points par pi√®ce
        updateScore();
        sCoin();
        spawnParts(c.x,c.y,'#FFD700',7,4);
        updateHUD();
        
        // Activer firepower √† 10 pi√®ces
        if(coins_count >= 10 && !firePowerActive) {
          firePowerActive = true;
          firePowerTimer = 600; // 10 secondes √† 60 FPS
          coins_count = 0; // Reset le compteur
          flash('#ff8800',15);
          
          // D√©marrer la musique de feu
          const bgMusic = document.getElementById('bgmusic');
          const fireMusic = document.getElementById('firemusic');
          const invMusic = document.getElementById('invmusic');
          
          // Si invincible, arr√™ter la musique d'invincibilit√©, sinon arr√™ter la musique normale
          if(hero.invincible) {
            invMusic.pause();
          } else {
            bgMusic.pause();
          }
          
          fireMusic.currentTime = 0;
          fireMusic.play().catch(e => console.log('Fire music play prevented:', e));
        }
        
        return false;
      }
      return true;
    });

    // FIREPOWER MODE
    if(firePowerActive) {
      firePowerTimer--;
      
      // Tirer une boule de feu toutes les 20 frames (~3 par seconde)
      if(F % 20 === 0) {
        fireballs.push({
          x: hero.x + 40,
          y: hero.y - 30,
          t: 0
        });
      }
      
      // D√©sactiver apr√®s 10 secondes
      if(firePowerTimer <= 0) {
        firePowerActive = false;
        
        // Arr√™ter la musique de feu et reprendre la musique appropri√©e
        const bgMusic = document.getElementById('bgmusic');
        const fireMusic = document.getElementById('firemusic');
        const invMusic = document.getElementById('invmusic');
        
        fireMusic.pause();
        
        // Si invincible, reprendre la musique d'invincibilit√©, sinon reprendre la musique normale
        if(hero.invincible) {
          invMusic.play().catch(e => console.log('Invincible music resume prevented:', e));
        } else {
          bgMusic.play().catch(e => console.log('Background music resume prevented:', e));
        }
        
        // Ne retirer le banner que si l'invincibilit√© n'est plus active
        if(!hero.invincible) document.getElementById('invbanner').classList.remove('on');
      } else {
        // N'afficher le timer firepower que si l'invincibilit√© n'est PAS active
        if(!hero.invincible) {
          document.getElementById('invbanner').textContent = 'üî• FIREPOWER! ' + Math.ceil(firePowerTimer/60) + 's';
          document.getElementById('invbanner').classList.add('on');
        }
      }
    }
    
    // G√©rer les boules de feu
    fireballs = fireballs.filter(fb => {
      fb.x += 8; // Vitesse des boules de feu
      fb.t++;
      const sx = fb.x - camX;
      
      // Dispara√Ætre si hors √©cran
      if(sx > W + 50) return false;
      
      // Dessiner la boule de feu
      drawFireball(sx, fb.y, fb.t);
      
      // Tuer les ennemis
      enemies = enemies.filter(en => {
        const ex = en.x - camX;
        if(ovlp(sx-15, fb.y-15, 30, 30, ex-18, GY-72, 36, 72)) {
          enemyDeathEffect(en.x, en.y);
          return false; // Ennemi tu√©
        }
        return true;
      });
      
      return true;
    });

    // UNICORN - Spawn et gestion
    spawnUnicorn();
    
    if(unicorn) {
      unicorn.x -= 3; // Vole vers la gauche
      unicorn.t++;
      
      // Mouvement vertical fluide (change d'altitude)
      // Changer de cible toutes les 120 frames (~2 secondes)
      if(unicorn.t % 120 === 0) {
        const heights = [GY-120, GY-160, GY-200, GY-240, GY-280];
        unicorn.targetY = heights[Math.floor(Math.random()*heights.length)];
      }
      
      // Se d√©placer progressivement vers l'altitude cible
      const diff = unicorn.targetY - unicorn.y;
      unicorn.vy += diff * 0.002; // Acc√©l√©ration douce
      unicorn.vy *= 0.92; // Friction
      unicorn.y += unicorn.vy;
      
      // Ajouter √† la tra√Æn√©e
      if(unicorn.t % 2 === 0) {
        unicornTrail.push({x: unicorn.x + 26, y: unicorn.y});
        if(unicornTrail.length > 30) {
          unicornTrail.shift(); // Limiter la longueur de la tra√Æn√©e
        }
      }
      
      const sx = unicorn.x - camX;
      
      // Dessiner la licorne
      drawUnicorn(sx, unicorn.y, unicorn.t, unicornTrail);
      
      // Collision avec le h√©ros
      const uw = 60, uh = 80;
      if(ovlp(hrx-camX, hry, HERO_W2, HERO_H2, sx-uw/2, unicorn.y-uh/2, uw, uh)) {
        // Capturer la licorne!
        score += 200; // 200 points pour la licorne
        updateScore();
        
        sUnicornCatch(); // Son magique!
        spawnParts(unicorn.x, unicorn.y, '#ff88ff', 20, 8);
        spawnParts(unicorn.x, unicorn.y, '#88ddff', 15, 6);
        flash('#ff88ff', 20);
        
        // Pause et afficher l'√©cran de gamble
        state = 'paused';
        gambleMultiplier = multip;
        showGambleScreen = true;
        
        document.getElementById('gambleScreen').style.display = 'flex';
        document.getElementById('gambleText').innerHTML = 
          `Current multiplier: <span style="color:#FFD700">√ó${multip.toFixed(2)}</span><br><br>` +
          `Risk it for <span style="color:#44ff88">√ó${(multip*2).toFixed(2)}</span>?<br>` +
          `or lose to <span style="color:#ff4444">√ó${(multip/2).toFixed(2)}</span>?<br><br>` +
          `<span style="color:#888;font-size:14px;">49% chance to win</span>`;
        
        unicorn = null;
        unicornTrail = [];
      }
      
      // Dispara√Ætre si hors √©cran
      if(sx < -100) {
        unicorn = null;
        unicornTrail = [];
      }
    }

    // SPIKE WALL ‚Äî spawn depuis le bord droit au frame suivant la disparition du portail
    if(spikeWallPending && !spikeWall){
      spikeWall={x:camX+W+50, t:0};
      spikeWallPending=false;
    }

    // SPIKE WALL ‚Äî position monde fixe, le h√©ros avance vers lui
    if(spikeWall){
      spikeWall.t++;
      const swsx=spikeWall.x-camX;
      drawSpikeWall(swsx,spikeWall.t);
      // Collision ‚Üí triggerCrash (mur in√©vitable, pas hitHero)
      if(ovlp(hrx-camX,hry,HERO_W2,HERO_H2, swsx-48,GY-300,48,300)){
        spawnParts(hero.x,hero.y-60,'#ff0000',25,9);
        spawnParts(hero.x,hero.y-40,'#cc2200',15,6);
        flash('#ff0000',30);
        triggerCrash();
      }
    }

    // RACCOON HERO
    if (hero.koAnimating && koFrames.length > 0) {
      // Animation KO
      const elapsed = Date.now() - hero.koStartTime;
      const frameIndex = Math.min(Math.floor(elapsed / 150), koFrames.length - 1);
      const koImg = koFrames[frameIndex];
      
      if (koImg && koImg.complete) {
        const koWidth = 120;
        const koHeight = 120;
        ctx.drawImage(koImg, hero.x - camX - koWidth/2, hero.y - koHeight, koWidth, koHeight);
      }
    } else if (hero.invincible && bullRideFrames.length > 0 && bullRideLoaded > 0) {
      // Animation BULL RIDE pendant l'invincibilit√©
      const bullFrameIdx = Math.floor(hero.frame / 4) % bullRideFrames.length;
      const bullImg = bullRideFrames[bullFrameIdx];
      
      // Clignoter pendant les 1.5 derni√®res secondes (90 frames)
      const shouldBlink = hero.inv <= 90 && (F >> 2) & 1; // Clignote toutes les ~4 frames
      
      if (shouldBlink) {
        // Pendant le clignotement, afficher le raton laveur normal avec aura
        const fi=Math.floor(hero.frame/8)%2;
        drawRaccoon(hero.x-camX,hero.y,fi,true,false,0);
      } else if (bullImg && bullImg.complete) {
        // Afficher le taureau normalement
        // Dimensions : ratio 213x130 ‚Üí on scale pour que la hauteur = ~110px
        const bh = 165;
        const bw = Math.round(bullImg.naturalWidth / bullImg.naturalHeight * bh);
        const bx = hero.x - camX - bw * 0.55; // aligner le dos du taureau avec la position hero
        const by = hero.y - bh;
        // Aura dor√©e
        ctx.save();
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 20;
        ctx.drawImage(bullImg, bx, by, bw, bh);
        ctx.restore();
      }
    } else {
      // Animation normale
      const fi=Math.floor(hero.frame/8)%2;
      drawRaccoon(hero.x-camX,hero.y,fi,hero.inv>0,false,0);
    }

  } else {
    // Idle / cashed ‚Äî raccoon removed from title screen
    F++;
  }

  drawParts();

  // EFFET DE WARPING lors du cashout
  if(warpEffect){
    warpProgress++;
    const progress = warpProgress / warpMaxDuration; // 0 √† 1
    
    // Faire appara√Ætre progressivement l'√©cran de victoire
    const victoryScreen = document.getElementById('victoryScreen');
    if(progress < 0.6) {
      victoryScreen.style.opacity = '0';
    } else {
      const fadeProgress = (progress - 0.6) / 0.4;
      victoryScreen.style.opacity = fadeProgress.toString();
    }
    
    const centerX = W / 2;
    const centerY = H / 2;
    const maxDist = Math.sqrt((W/2) * (W/2) + (H/2) * (H/2));
    
    // Gradients radiaux simples au lieu du pixel warping lourd
    if(progress < 0.4) {
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxDist);
      gradient.addColorStop(0, `rgba(153, 69, 255, ${progress * 0.3})`);
      gradient.addColorStop(0.5, `rgba(153, 69, 255, ${progress * 0.2})`);
      gradient.addColorStop(1, 'rgba(20, 10, 40, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
    } else if(progress < 0.7) {
      const localProgress = (progress - 0.4) / 0.3;
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxDist * (1 - localProgress * 0.5));
      gradient.addColorStop(0, `rgba(255, 255, 255, ${localProgress * 0.6})`);
      gradient.addColorStop(0.3, `rgba(153, 69, 255, ${0.5})`);
      gradient.addColorStop(0.6, `rgba(153, 69, 255, ${0.3})`);
      gradient.addColorStop(1, 'rgba(20, 10, 40, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
    } else {
      const localProgress = (progress - 0.7) / 0.3;
      const fadeOut = 1 - ((progress - 0.6) / 0.4);
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxDist * (1 - localProgress * 0.8));
      gradient.addColorStop(0, `rgba(255, 255, 255, ${(0.6 + localProgress * 0.4) * Math.max(0, fadeOut)})`);
      gradient.addColorStop(0.4, `rgba(255, 215, 0, ${(0.4 + localProgress * 0.4) * Math.max(0, fadeOut)})`);
      gradient.addColorStop(0.7, `rgba(153, 69, 255, ${0.3 * Math.max(0, fadeOut)})`);
      gradient.addColorStop(1, `rgba(0, 0, 0, ${localProgress * 0.5 * Math.max(0, fadeOut)})`);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
    }
    
    // Particules brillantes r√©duites (30 au lieu de 100)
    const particleCount = 30;
    for(let i = 0; i < particleCount; i++){
      const angleOffset = (i / particleCount) * Math.PI * 2;
      const spiralAngle = angleOffset + progress * Math.PI * 8;
      const radius = maxDist * (1 - progress) * (0.5 + Math.sin(angleOffset * 3) * 0.3);
      const px = centerX + Math.cos(spiralAngle) * radius;
      const py = centerY + Math.sin(spiralAngle) * radius;
      const size = 2 + Math.random() * 5 * (1 + progress);
      
      const particleFadeOut = progress < 0.6 ? 1 : 1 - ((progress - 0.6) / 0.4);
      
      let r, g, b;
      if(progress < 0.5) {
        r = 153 + (255 - 153) * (progress * 2);
        g = 69 + (215 - 69) * (progress * 2);
        b = 255;
      } else {
        const p2 = (progress - 0.5) * 2;
        r = 255;
        g = 215 + (255 - 215) * p2;
        b = 255 * (1 - p2) + 255 * p2;
      }
      
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.9 * (1 - progress * 0.5) * particleFadeOut})`;
      ctx.beginPath();
      ctx.arc(px, py, size, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Terminer l'effet
    if(progress >= 1) {
      warpEffect = false;
      document.getElementById('ov').classList.add('hide');
    }
  }

  if(flashT>0){ctx.globalAlpha=flashT/28*.28;ctx.fillStyle=flashC;ctx.fillRect(0,0,W,H);ctx.globalAlpha=1;flashT--;}

  requestAnimationFrame(loop);
}

updateHUD();totalWaves=6;

// Charger le solde sauvegard√©
loadBalance();
updateBal(); // Afficher le solde charg√©

// Initialiser l'affichage USD du bet
function updateBetUSD() {
  const betValue = parseFloat(document.getElementById('bip').value) || 0.10;
  const usdValue = (betValue * SOL_PRICE).toFixed(2);
  document.getElementById('betusd').textContent = `($${parseFloat(usdValue).toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:2})})`;
}
updateBetUSD();

// Mettre √† jour l'USD quand l'utilisateur change le bet manuellement
document.getElementById('bip').addEventListener('input', updateBetUSD);

// Initialiser le bet de victoire
updateBetVictoryUSD();
document.getElementById('bipVictory').addEventListener('input', updateBetVictoryUSD);

loop();
</script>
</body>
</html>